--- a/Lib/bsddb/__init__.py
+++ b/Lib/bsddb/__init__.py
@@ -33,7 +33,7 @@
 #----------------------------------------------------------------------
 
 
-"""Support for Berkeley DB 4.0 through 4.7 with a simple interface.
+"""Support for Berkeley DB 4.3 through 5.3 with a simple interface.
 
 For the full featured object oriented interface use the bsddb.db module
 instead.  It mirrors the Oracle Berkeley DB C API.
@@ -42,11 +42,14 @@
 import sys
 absolute_import = (sys.version_info[0] >= 3)
 
-if sys.py3kwarning:
+if (sys.version_info >= (2, 6)) and (sys.version_info < (3, 0)) :
     import warnings
-    warnings.warnpy3k("in 3.x, the bsddb module has been removed; "
-                      "please use the pybsddb project instead",
-                      DeprecationWarning, 2)
+    if sys.py3kwarning and (__name__ != 'bsddb3') :
+        warnings.warnpy3k("in 3.x, the bsddb module has been removed; "
+                          "please use the pybsddb project instead",
+                          DeprecationWarning, 2)
+    warnings.filterwarnings("ignore", ".*CObject.*", DeprecationWarning,
+                            "bsddb.__init__")
 
 try:
     if __name__ == 'bsddb3':
@@ -81,7 +84,7 @@
 
 from weakref import ref
 
-if sys.version_info[0:2] <= (2, 5) :
+if sys.version_info < (2, 6) :
     import UserDict
     MutableMapping = UserDict.DictMixin
 else :
@@ -135,7 +138,7 @@
             except _bsddb.DBCursorClosedError:
                 # the database was modified during iteration.  abort.
                 pass
-# When Python 2.3 not supported in bsddb3, we can change this to "finally"
+# When Python 2.4 not supported in bsddb3, we can change this to "finally"
         except :
             self._in_iter -= 1
             raise
@@ -178,7 +181,7 @@
             except _bsddb.DBCursorClosedError:
                 # the database was modified during iteration.  abort.
                 pass
-# When Python 2.3 not supported in bsddb3, we can change this to "finally"
+# When Python 2.4 not supported in bsddb3, we can change this to "finally"
         except :
             self._in_iter -= 1
             raise
@@ -256,7 +259,7 @@
         self._checkOpen()
         return _DeadlockWrap(lambda: len(self.db))  # len(self.db)
 
-    if sys.version_info[0:2] >= (2, 6) :
+    if sys.version_info >= (2, 6) :
         def __repr__(self) :
             if self.isOpen() :
                 return repr(dict(_DeadlockWrap(self.db.items)))
@@ -442,8 +445,10 @@
 # Berkeley DB was too.
 
 try:
-    import thread
-    del thread
+    # 2to3 automatically changes "import thread" to "import _thread"
+    import thread as T
+    del T
+
 except ImportError:
     db.DB_THREAD = 0
 
--- a/Lib/bsddb/dbobj.py
+++ b/Lib/bsddb/dbobj.py
@@ -29,13 +29,8 @@
 else :
     import db
 
-if sys.version_info[0:2] <= (2, 5) :
-    try:
-        from UserDict import DictMixin
-    except ImportError:
-        # DictMixin is new in Python 2.3
-        class DictMixin: pass
-    MutableMapping = DictMixin
+if sys.version_info < (2, 6) :
+    from UserDict import DictMixin as MutableMapping
 else :
     import collections
     MutableMapping = collections.MutableMapping
@@ -110,15 +105,17 @@
     def log_stat(self, *args, **kwargs):
         return self._cobj.log_stat(*args, **kwargs)
 
-    if db.version() >= (4,1):
-        def dbremove(self, *args, **kwargs):
-            return self._cobj.dbremove(*args, **kwargs)
-        def dbrename(self, *args, **kwargs):
-            return self._cobj.dbrename(*args, **kwargs)
-        def set_encrypt(self, *args, **kwargs):
-            return self._cobj.set_encrypt(*args, **kwargs)
+    def dbremove(self, *args, **kwargs):
+        return self._cobj.dbremove(*args, **kwargs)
+    def dbrename(self, *args, **kwargs):
+        return self._cobj.dbrename(*args, **kwargs)
+    def set_encrypt(self, *args, **kwargs):
+        return self._cobj.set_encrypt(*args, **kwargs)
 
     if db.version() >= (4,4):
+        def fileid_reset(self, *args, **kwargs):
+            return self._cobj.fileid_reset(*args, **kwargs)
+
         def lsn_reset(self, *args, **kwargs):
             return self._cobj.lsn_reset(*args, **kwargs)
 
@@ -138,7 +135,7 @@
     def __delitem__(self, arg):
         del self._cobj[arg]
 
-    if sys.version_info[0:2] >= (2, 6) :
+    if sys.version_info >= (2, 6) :
         def __iter__(self) :
             return self._cobj.__iter__()
 
@@ -194,6 +191,8 @@
         return self._cobj.set_bt_compare(*args, **kwargs)
     def set_cachesize(self, *args, **kwargs):
         return self._cobj.set_cachesize(*args, **kwargs)
+    def set_dup_compare(self, *args, **kwargs) :
+        return self._cobj.set_dup_compare(*args, **kwargs)
     def set_flags(self, *args, **kwargs):
         return self._cobj.set_flags(*args, **kwargs)
     def set_h_ffactor(self, *args, **kwargs):
@@ -229,9 +228,8 @@
     def set_get_returns_none(self, *args, **kwargs):
         return self._cobj.set_get_returns_none(*args, **kwargs)
 
-    if db.version() >= (4,1):
-        def set_encrypt(self, *args, **kwargs):
-            return self._cobj.set_encrypt(*args, **kwargs)
+    def set_encrypt(self, *args, **kwargs):
+        return self._cobj.set_encrypt(*args, **kwargs)
 
 
 class DBSequence:
--- a/Lib/bsddb/dbshelve.py
+++ b/Lib/bsddb/dbshelve.py
@@ -1,4 +1,4 @@
-#!/bin/env python
+#!/usr/bin/env python
 #------------------------------------------------------------------------
 #           Copyright (c) 1997-2001 by Total Control Software
 #                         All Rights Reserved
@@ -29,9 +29,6 @@
 
 #------------------------------------------------------------------------
 
-import cPickle
-import sys
-
 import sys
 absolute_import = (sys.version_info[0] >= 3)
 if absolute_import :
@@ -40,30 +37,43 @@
 else :
     import db
 
-#At version 2.3 cPickle switched to using protocol instead of bin
-if sys.version_info[:3] >= (2, 3, 0):
-    HIGHEST_PROTOCOL = cPickle.HIGHEST_PROTOCOL
-# In python 2.3.*, "cPickle.dumps" accepts no
-# named parameters. "pickle.dumps" accepts them,
-# so this seems a bug.
-    if sys.version_info[:3] < (2, 4, 0):
-        def _dumps(object, protocol):
-            return cPickle.dumps(object, protocol)
+if sys.version_info[0] >= 3 :
+    import cPickle  # Will be converted to "pickle" by "2to3"
+else :
+    if sys.version_info < (2, 6) :
+        import cPickle
     else :
-        def _dumps(object, protocol):
-            return cPickle.dumps(object, protocol=protocol)
-
-else:
-    HIGHEST_PROTOCOL = None
-    def _dumps(object, protocol):
-        return cPickle.dumps(object, bin=protocol)
+        # When we drop support for python 2.4
+        # we could use: (in 2.5 we need a __future__ statement)
+        #
+        #    with warnings.catch_warnings():
+        #        warnings.filterwarnings(...)
+        #        ...
+        #
+        # We can not use "with" as is, because it would be invalid syntax
+        # in python 2.4 and (with no __future__) 2.5.
+        # Here we simulate "with" following PEP 343 :
+        import warnings
+        w = warnings.catch_warnings()
+        w.__enter__()
+        try :
+            warnings.filterwarnings('ignore',
+                message='the cPickle module has been removed in Python 3.0',
+                category=DeprecationWarning)
+            import cPickle
+        finally :
+            w.__exit__()
+        del w
+
+HIGHEST_PROTOCOL = cPickle.HIGHEST_PROTOCOL
+def _dumps(object, protocol):
+    return cPickle.dumps(object, protocol=protocol)
 
-
-try:
-    from UserDict import DictMixin
-except ImportError:
-    # DictMixin is new in Python 2.3
-    class DictMixin: pass
+if sys.version_info < (2, 6) :
+    from UserDict import DictMixin as MutableMapping
+else :
+    import collections
+    MutableMapping = collections.MutableMapping
 
 #------------------------------------------------------------------------
 
@@ -106,7 +116,7 @@
 class DBShelveError(db.DBError): pass
 
 
-class DBShelf(DictMixin):
+class DBShelf(MutableMapping):
     """A shelf to hold pickled objects, built upon a bsddb DB object.  It
     automatically pickles/unpickles data objects going to/from the DB.
     """
@@ -157,6 +167,17 @@
         else:
             return self.db.keys()
 
+    if sys.version_info >= (2, 6) :
+        def __iter__(self) :  # XXX: Load all keys in memory :-(
+            for k in self.db.keys() :
+                yield k
+
+        # Do this when "DB"  support iteration
+        # Or is it enough to pass thru "getattr"?
+        #
+        # def __iter__(self) :
+        #    return self.db.__iter__()
+
 
     def open(self, *args, **kwargs):
         self.db.open(*args, **kwargs)
--- a/Lib/bsddb/dbtables.py
+++ b/Lib/bsddb/dbtables.py
@@ -22,7 +22,35 @@
 import copy
 import random
 import struct
-import cPickle as pickle
+
+
+if sys.version_info[0] >= 3 :
+    import pickle
+else :
+    if sys.version_info < (2, 6) :
+        import cPickle as pickle
+    else :
+        # When we drop support for python 2.4
+        # we could use: (in 2.5 we need a __future__ statement)
+        #
+        #    with warnings.catch_warnings():
+        #        warnings.filterwarnings(...)
+        #        ...
+        #
+        # We can not use "with" as is, because it would be invalid syntax
+        # in python 2.4 and (with no __future__) 2.5.
+        # Here we simulate "with" following PEP 343 :
+        import warnings
+        w = warnings.catch_warnings()
+        w.__enter__()
+        try :
+            warnings.filterwarnings('ignore',
+                message='the cPickle module has been removed in Python 3.0',
+                category=DeprecationWarning)
+            import cPickle as pickle
+        finally :
+            w.__exit__()
+        del w
 
 try:
     # For Pythons w/distutils pybsddb
@@ -31,12 +59,6 @@
     # For Python 2.3
     from bsddb import db
 
-# XXX(nnorwitz): is this correct? DBIncompleteError is conditional in _bsddb.c
-if not hasattr(db,"DBIncompleteError") :
-    class DBIncompleteError(Exception):
-        pass
-    db.DBIncompleteError = DBIncompleteError
-
 class TableDBError(StandardError):
     pass
 class TableAlreadyExists(TableDBError):
@@ -261,16 +283,10 @@
             self.env = None
 
     def checkpoint(self, mins=0):
-        try:
-            self.env.txn_checkpoint(mins)
-        except db.DBIncompleteError:
-            pass
+        self.env.txn_checkpoint(mins)
 
     def sync(self):
-        try:
-            self.db.sync()
-        except db.DBIncompleteError:
-            pass
+        self.db.sync()
 
     def _db_print(self) :
         """Print the database to stdout for debugging"""
@@ -398,7 +414,7 @@
                 # column names
                 newcolumnlist = copy.copy(oldcolumnlist)
                 for c in columns:
-                    if c not in oldcolumnhash:
+                    if not c in oldcolumnhash:
                         newcolumnlist.append(c)
 
                 # store the table's new extended column list
@@ -615,7 +631,7 @@
           argument and returning a boolean.
         """
         try:
-            if table not in self.__tablecolumns:
+            if not table in self.__tablecolumns:
                 self.__load_column_info(table)
             if columns is None:
                 columns = self.__tablecolumns[table]
@@ -659,6 +675,13 @@
             a = atuple[1]
             b = btuple[1]
             if type(a) is type(b):
+
+                # Needed for python 3. "cmp" vanished in 3.0.1
+                def cmp(a, b) :
+                    if a==b : return 0
+                    if a<b : return -1
+                    return 1
+
                 if isinstance(a, PrefixCond) and isinstance(b, PrefixCond):
                     # longest prefix first
                     return cmp(len(b.prefix), len(a.prefix))
--- a/Modules/_bsddb.c
+++ b/Modules/_bsddb.c
@@ -64,7 +64,7 @@
  *
  * http://www.python.org/peps/pep-0291.html
  *
- * This module contains 6 types:
+ * This module contains 7 types:
  *
  * DB           (Database)
  * DBCursor     (Database Cursor)
@@ -72,6 +72,11 @@
  * DBTxn        (An explicit database transaction)
  * DBLock       (A lock handle)
  * DBSequence   (Sequence)
+ * DBSite       (Site)
+ *
+ * More datatypes added:
+ *
+ * DBLogCursor  (Log Cursor)
  *
  */
 
@@ -131,34 +136,11 @@
 #define MYDB_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS;
 #define MYDB_END_ALLOW_THREADS Py_END_ALLOW_THREADS;
 
-/* For 2.3, use the PyGILState_ calls */
-#if (PY_VERSION_HEX >= 0x02030000)
-#define MYDB_USE_GILSTATE
-#endif
-
 /* and these are for calling C --> Python */
-#if defined(MYDB_USE_GILSTATE)
 #define MYDB_BEGIN_BLOCK_THREADS \
                 PyGILState_STATE __savestate = PyGILState_Ensure();
 #define MYDB_END_BLOCK_THREADS \
                 PyGILState_Release(__savestate);
-#else /* MYDB_USE_GILSTATE */
-/* Pre GILState API - do it the long old way */
-static PyInterpreterState* _db_interpreterState = NULL;
-#define MYDB_BEGIN_BLOCK_THREADS {                              \
-        PyThreadState* prevState;                               \
-        PyThreadState* newState;                                \
-        PyEval_AcquireLock();                                   \
-        newState  = PyThreadState_New(_db_interpreterState);    \
-        prevState = PyThreadState_Swap(newState);
-
-#define MYDB_END_BLOCK_THREADS                                  \
-        newState = PyThreadState_Swap(prevState);               \
-        PyThreadState_Clear(newState);                          \
-        PyEval_ReleaseLock();                                   \
-        PyThreadState_Delete(newState);                         \
-        }
-#endif /* MYDB_USE_GILSTATE */
 
 #else
 /* Compiled without threads - avoid all this cruft */
@@ -169,9 +151,6 @@
 
 #endif
 
-/* Should DB_INCOMPLETE be turned into a warning or an exception? */
-#define INCOMPLETE_IS_WARNING 1
-
 /* --------------------------------------------------------------------- */
 /* Exceptions */
 
@@ -186,35 +165,39 @@
 static PyObject* DBRunRecoveryError;    /* DB_RUNRECOVERY */
 static PyObject* DBVerifyBadError;      /* DB_VERIFY_BAD */
 static PyObject* DBNoServerError;       /* DB_NOSERVER */
+#if (DBVER < 52)
 static PyObject* DBNoServerHomeError;   /* DB_NOSERVER_HOME */
 static PyObject* DBNoServerIDError;     /* DB_NOSERVER_ID */
+#endif
 static PyObject* DBPageNotFoundError;   /* DB_PAGE_NOTFOUND */
 static PyObject* DBSecondaryBadError;   /* DB_SECONDARY_BAD */
 
-#if !INCOMPLETE_IS_WARNING
-static PyObject* DBIncompleteError;     /* DB_INCOMPLETE */
-#endif
-
 static PyObject* DBInvalidArgError;     /* EINVAL */
 static PyObject* DBAccessError;         /* EACCES */
 static PyObject* DBNoSpaceError;        /* ENOSPC */
-static PyObject* DBNoMemoryError;       /* DB_BUFFER_SMALL (ENOMEM when < 4.3) */
+static PyObject* DBNoMemoryError;       /* DB_BUFFER_SMALL */
 static PyObject* DBAgainError;          /* EAGAIN */
 static PyObject* DBBusyError;           /* EBUSY  */
 static PyObject* DBFileExistsError;     /* EEXIST */
 static PyObject* DBNoSuchFileError;     /* ENOENT */
 static PyObject* DBPermissionsError;    /* EPERM  */
 
-#if (DBVER >= 42)
 static PyObject* DBRepHandleDeadError;  /* DB_REP_HANDLE_DEAD */
+#if (DBVER >= 44)
+static PyObject* DBRepLockoutError;     /* DB_REP_LOCKOUT */
 #endif
 
-static PyObject* DBRepUnavailError;     /* DB_REP_UNAVAIL */
+#if (DBVER >= 46)
+static PyObject* DBRepLeaseExpiredError; /* DB_REP_LEASE_EXPIRED */
+#endif
 
-#if (DBVER < 43)
-#define DB_BUFFER_SMALL         ENOMEM
+#if (DBVER >= 47)
+static PyObject* DBForeignConflictError; /* DB_FOREIGN_CONFLICT */
 #endif
 
+
+static PyObject* DBRepUnavailError;     /* DB_REP_UNAVAIL */
+
 #if (DBVER < 48)
 #define DB_GID_SIZE DB_XIDDATASIZE
 #endif
@@ -242,9 +225,10 @@
 #endif
 
 staticforward PyTypeObject DB_Type, DBCursor_Type, DBEnv_Type, DBTxn_Type,
-              DBLock_Type;
-#if (DBVER >= 43)
+              DBLock_Type, DBLogCursor_Type;
 staticforward PyTypeObject DBSequence_Type;
+#if (DBVER >= 52)
+staticforward PyTypeObject DBSite_Type;
 #endif
 
 #ifndef Py_TYPE
@@ -254,11 +238,13 @@
 
 #define DBObject_Check(v)           (Py_TYPE(v) == &DB_Type)
 #define DBCursorObject_Check(v)     (Py_TYPE(v) == &DBCursor_Type)
+#define DBLogCursorObject_Check(v)  (Py_TYPE(v) == &DBLogCursor_Type)
 #define DBEnvObject_Check(v)        (Py_TYPE(v) == &DBEnv_Type)
 #define DBTxnObject_Check(v)        (Py_TYPE(v) == &DBTxn_Type)
 #define DBLockObject_Check(v)       (Py_TYPE(v) == &DBLock_Type)
-#if (DBVER >= 43)
 #define DBSequenceObject_Check(v)   (Py_TYPE(v) == &DBSequence_Type)
+#if (DBVER >= 52)
+#define DBSiteObject_Check(v)       (Py_TYPE(v) == &DBSite_Type)
 #endif
 
 #if (DBVER < 46)
@@ -359,9 +345,15 @@
 #define CHECK_CURSOR_NOT_CLOSED(curs) \
         _CHECK_OBJECT_NOT_CLOSED(curs->dbc, DBCursorClosedError, DBCursor)
 
-#if (DBVER >= 43)
+#define CHECK_LOGCURSOR_NOT_CLOSED(logcurs) \
+        _CHECK_OBJECT_NOT_CLOSED(logcurs->logc, DBCursorClosedError, DBLogCursor)
+
 #define CHECK_SEQUENCE_NOT_CLOSED(curs) \
         _CHECK_OBJECT_NOT_CLOSED(curs->sequence, DBError, DBSequence)
+
+#if (DBVER >= 52)
+#define CHECK_SITE_NOT_CLOSED(db_site) \
+         _CHECK_OBJECT_NOT_CLOSED(db_site->site, DBError, DBSite)
 #endif
 
 #define CHECK_DBFLAG(mydb, flag)    (((mydb)->flags & (flag)) || \
@@ -554,12 +546,8 @@
 /* Callback used to save away more information about errors from the DB
  * library. */
 static char _db_errmsg[1024];
-#if (DBVER <= 42)
-static void _db_errorCallback(const char* prefix, char* msg)
-#else
 static void _db_errorCallback(const DB_ENV *db_env,
         const char* prefix, const char* msg)
-#endif
 {
     our_strlcpy(_db_errmsg, msg, sizeof(_db_errmsg));
 }
@@ -613,11 +601,7 @@
       return NULL;
   }
 
-#if (PY_VERSION_HEX >= 0x02040000)
   r = PyTuple_Pack(2, a, b) ;
-#else
-  r = Py_BuildValue("OO", a, b);
-#endif
   Py_DECREF(a);
   Py_DECREF(b);
   return r;
@@ -671,27 +655,8 @@
     unsigned int bytes_left;
 
     switch (err) {
-        case 0:                     /* successful, no error */      break;
-
-#if (DBVER < 41)
-        case DB_INCOMPLETE:
-#if INCOMPLETE_IS_WARNING
-            bytes_left = our_strlcpy(errTxt, db_strerror(err), sizeof(errTxt));
-            /* Ensure that bytes_left never goes negative */
-            if (_db_errmsg[0] && bytes_left < (sizeof(errTxt) - 4)) {
-                bytes_left = sizeof(errTxt) - bytes_left - 4 - 1;
-                assert(bytes_left >= 0);
-                strcat(errTxt, " -- ");
-                strncat(errTxt, _db_errmsg, bytes_left);
-            }
-            _db_errmsg[0] = 0;
-            exceptionRaised = PyErr_Warn(PyExc_RuntimeWarning, errTxt);
-
-#else  /* do an exception instead */
-        errObj = DBIncompleteError;
-#endif
-        break;
-#endif /* DBVER < 41 */
+        case 0:                     /* successful, no error */
+            return 0;
 
         case DB_KEYEMPTY:           errObj = DBKeyEmptyError;       break;
         case DB_KEYEXIST:           errObj = DBKeyExistError;       break;
@@ -702,16 +667,15 @@
         case DB_RUNRECOVERY:        errObj = DBRunRecoveryError;    break;
         case DB_VERIFY_BAD:         errObj = DBVerifyBadError;      break;
         case DB_NOSERVER:           errObj = DBNoServerError;       break;
+#if (DBVER < 52)
         case DB_NOSERVER_HOME:      errObj = DBNoServerHomeError;   break;
         case DB_NOSERVER_ID:        errObj = DBNoServerIDError;     break;
+#endif
         case DB_PAGE_NOTFOUND:      errObj = DBPageNotFoundError;   break;
         case DB_SECONDARY_BAD:      errObj = DBSecondaryBadError;   break;
         case DB_BUFFER_SMALL:       errObj = DBNoMemoryError;       break;
 
-#if (DBVER >= 43)
-        /* ENOMEM and DB_BUFFER_SMALL were one and the same until 4.3 */
         case ENOMEM:  errObj = PyExc_MemoryError;   break;
-#endif
         case EINVAL:  errObj = DBInvalidArgError;   break;
         case EACCES:  errObj = DBAccessError;       break;
         case ENOSPC:  errObj = DBNoSpaceError;      break;
@@ -721,8 +685,17 @@
         case ENOENT:  errObj = DBNoSuchFileError;   break;
         case EPERM :  errObj = DBPermissionsError;  break;
 
-#if (DBVER >= 42)
         case DB_REP_HANDLE_DEAD : errObj = DBRepHandleDeadError; break;
+#if (DBVER >= 44)
+        case DB_REP_LOCKOUT : errObj = DBRepLockoutError; break;
+#endif
+
+#if (DBVER >= 46)
+        case DB_REP_LEASE_EXPIRED : errObj = DBRepLeaseExpiredError; break;
+#endif
+
+#if (DBVER >= 47)
+        case DB_FOREIGN_CONFLICT : errObj = DBForeignConflictError; break;
 #endif
 
         case DB_REP_UNAVAIL : errObj = DBRepUnavailError; break;
@@ -792,7 +765,6 @@
     if (makeDBError(err)) {
         return -1;
     }
-    self->haveStat = 0;
     return 0;
 }
 
@@ -809,7 +781,6 @@
     if (makeDBError(err)) {
         return -1;
     }
-    self->haveStat = 0;
     return 0;
 }
 
@@ -899,7 +870,6 @@
     Py_XDECREF(v);
 }
 
-#if (DBVER >= 43)
 /* add an db_seq_t to a dictionary using the given name as a key */
 static void _addDb_seq_tToDict(PyObject* dict, char *name, db_seq_t value)
 {
@@ -909,7 +879,6 @@
 
     Py_XDECREF(v);
 }
-#endif
 
 static void _addDB_lsnToDict(PyObject* dict, char *name, DB_LSN value)
 {
@@ -934,17 +903,15 @@
     if (self == NULL)
         return NULL;
 
-    self->haveStat = 0;
     self->flags = 0;
     self->setflags = 0;
     self->myenvobj = NULL;
     self->db = NULL;
     self->children_cursors = NULL;
-#if (DBVER >=43)
     self->children_sequences = NULL;
-#endif
     self->associateCallback = NULL;
     self->btCompareCallback = NULL;
+    self->dupCompareCallback = NULL;
     self->primaryDBType = 0;
     Py_INCREF(Py_None);
     self->private_obj = Py_None;
@@ -1026,6 +993,10 @@
         Py_DECREF(self->btCompareCallback);
         self->btCompareCallback = NULL;
     }
+    if (self->dupCompareCallback != NULL) {
+        Py_DECREF(self->dupCompareCallback);
+        self->dupCompareCallback = NULL;
+    }
     Py_DECREF(self->private_obj);
     PyObject_Del(self);
 }
@@ -1081,6 +1052,54 @@
 }
 
 
+static DBLogCursorObject*
+newDBLogCursorObject(DB_LOGC* dblogc, DBEnvObject* env)
+{
+    DBLogCursorObject* self;
+
+    self = PyObject_New(DBLogCursorObject, &DBLogCursor_Type);
+
+    if (self == NULL)
+        return NULL;
+
+    self->logc = dblogc;
+    self->env = env;
+
+    INSERT_IN_DOUBLE_LINKED_LIST(self->env->children_logcursors, self);
+
+    self->in_weakreflist = NULL;
+    Py_INCREF(self->env);
+    return self;
+}
+
+
+/* Forward declaration */
+static PyObject *DBLogCursor_close_internal(DBLogCursorObject* self);
+
+static void
+DBLogCursor_dealloc(DBLogCursorObject* self)
+{
+    PyObject *dummy;
+
+    if (self->logc != NULL) {
+        dummy = DBLogCursor_close_internal(self);
+        /*
+        ** Raising exceptions while doing
+        ** garbage collection is a fatal error.
+        */
+        if (dummy)
+            Py_DECREF(dummy);
+        else
+            PyErr_Clear();
+    }
+    if (self->in_weakreflist != NULL) {
+        PyObject_ClearWeakRefs((PyObject *) self);
+    }
+    Py_DECREF(self->env);
+    PyObject_Del(self);
+}
+
+
 static DBEnvObject*
 newDBEnvObject(int flags)
 {
@@ -1096,6 +1115,10 @@
     self->moduleFlags.cursorSetReturnsNone = DEFAULT_CURSOR_SET_RETURNS_NONE;
     self->children_dbs = NULL;
     self->children_txns = NULL;
+    self->children_logcursors = NULL ;
+#if (DBVER >= 52)
+    self->children_sites = NULL;
+#endif
     Py_INCREF(Py_None);
     self->private_obj = Py_None;
     Py_INCREF(Py_None);
@@ -1167,6 +1190,8 @@
     self->flag_prepare = 0;
     self->parent_txn = NULL;
     self->env = NULL;
+    /* We initialize just in case "txn_begin" fails */
+    self->txn = NULL;
 
     if (parent && ((PyObject *)parent!=Py_None)) {
         parent_txn = parent->txn;
@@ -1180,6 +1205,7 @@
         MYDB_END_ALLOW_THREADS;
 
         if (makeDBError(err)) {
+            /* Free object half initialized */
             Py_DECREF(self);
             return NULL;
         }
@@ -1213,7 +1239,7 @@
     if (self->txn) {
         int flag_prepare = self->flag_prepare;
 
-        dummy=DBTxn_abort_discard_internal(self,0);
+        dummy=DBTxn_abort_discard_internal(self, 0);
         /*
         ** Raising exceptions while doing
         ** garbage collection is a fatal error.
@@ -1236,7 +1262,12 @@
     if (self->env) {
         Py_DECREF(self->env);
     } else {
-        Py_DECREF(self->parent_txn);
+        /*
+        ** We can have "self->env==NULL" and "self->parent_txn==NULL"
+        ** if something happens when creating the transaction object
+        ** and we abort the object while half done.
+        */
+        Py_XDECREF(self->parent_txn);
     }
     PyObject_Del(self);
 }
@@ -1251,6 +1282,7 @@
     if (self == NULL)
         return NULL;
     self->in_weakreflist = NULL;
+    self->lock_initialized = 0;  /* Just in case the call fails */
 
     MYDB_BEGIN_ALLOW_THREADS;
     err = myenv->db_env->lock_get(myenv->db_env, locker, flags, obj, lock_mode,
@@ -1259,6 +1291,8 @@
     if (makeDBError(err)) {
         Py_DECREF(self);
         self = NULL;
+    } else {
+        self->lock_initialized = 1;
     }
 
     return self;
@@ -1272,12 +1306,12 @@
         PyObject_ClearWeakRefs((PyObject *) self);
     }
     /* TODO: is this lock held? should we release it? */
+    /* CAUTION: The lock can be not initialized if the creation has failed */
 
     PyObject_Del(self);
 }
 
 
-#if (DBVER >= 43)
 static DBSequenceObject*
 newDBSequenceObject(DBObject* mydb,  int flags)
 {
@@ -1292,6 +1326,7 @@
     self->txn = NULL;
 
     self->in_weakreflist = NULL;
+    self->sequence = NULL;  /* Just in case the call fails */
 
     MYDB_BEGIN_ALLOW_THREADS;
     err = db_sequence_create(&self->sequence, self->mydb->db, flags);
@@ -1332,6 +1367,53 @@
     Py_DECREF(self->mydb);
     PyObject_Del(self);
 }
+
+#if (DBVER >= 52)
+static DBSiteObject*
+newDBSiteObject(DB_SITE* sitep, DBEnvObject* env)
+{
+    DBSiteObject* self;
+
+    self = PyObject_New(DBSiteObject, &DBSite_Type);
+
+    if (self == NULL)
+        return NULL;
+
+    self->site = sitep;
+    self->env = env;
+
+    INSERT_IN_DOUBLE_LINKED_LIST(self->env->children_sites, self);
+
+    self->in_weakreflist = NULL;
+    Py_INCREF(self->env);
+    return self;
+}
+
+/* Forward declaration */
+static PyObject *DBSite_close_internal(DBSiteObject* self);
+
+static void
+DBSite_dealloc(DBSiteObject* self)
+{
+    PyObject *dummy;
+
+    if (self->site != NULL) {
+        dummy = DBSite_close_internal(self);
+        /*
+        ** Raising exceptions while doing
+        ** garbage collection is a fatal error.
+        */
+        if (dummy)
+            Py_DECREF(dummy);
+        else
+            PyErr_Clear();
+    }
+    if (self->in_weakreflist != NULL) {
+        PyObject_ClearWeakRefs((PyObject *) self);
+    }
+    Py_DECREF(self->env);
+    PyObject_Del(self);
+}
 #endif
 
 /* --------------------------------------------------------------------- */
@@ -1421,10 +1503,70 @@
                 PyErr_Print();
             }
         }
+#if (DBVER >= 46)
+        else if (PyList_Check(result))
+        {
+            char* data;
+            Py_ssize_t size;
+            int i, listlen;
+            DBT* dbts;
+
+            listlen = PyList_Size(result);
+
+            dbts = (DBT *)malloc(sizeof(DBT) * listlen);
+
+            for (i=0; i<listlen; i++)
+            {
+                if (!PyBytes_Check(PyList_GetItem(result, i)))
+                {
+                    PyErr_SetString(
+                       PyExc_TypeError,
+#if (PY_VERSION_HEX < 0x03000000)
+"The list returned by DB->associate callback should be a list of strings.");
+#else
+"The list returned by DB->associate callback should be a list of bytes.");
+#endif
+                    PyErr_Print();
+                }
+
+                PyBytes_AsStringAndSize(
+                    PyList_GetItem(result, i),
+                    &data, &size);
+
+                CLEAR_DBT(dbts[i]);
+                dbts[i].data = malloc(size);          /* TODO, check this */
+
+                if (dbts[i].data)
+                {
+                    memcpy(dbts[i].data, data, size);
+                    dbts[i].size = size;
+                    dbts[i].ulen = dbts[i].size;
+                    dbts[i].flags = DB_DBT_APPMALLOC;  /* DB will free */
+                }
+                else
+                {
+                    PyErr_SetString(PyExc_MemoryError,
+                        "malloc failed in _db_associateCallback (list)");
+                    PyErr_Print();
+                }
+            }
+
+            CLEAR_DBT(*secKey);
+
+            secKey->data = dbts;
+            secKey->size = listlen;
+            secKey->flags = DB_DBT_APPMALLOC | DB_DBT_MULTIPLE;
+            retval = 0;
+        }
+#endif
         else {
             PyErr_SetString(
                PyExc_TypeError,
-               "DB associate callback should return DB_DONOTINDEX or string.");
+#if (PY_VERSION_HEX < 0x03000000)
+"DB associate callback should return DB_DONOTINDEX/string/list of strings.");
+#else
+"DB associate callback should return DB_DONOTINDEX/bytes/list of bytes.");
+#endif
             PyErr_Print();
         }
 
@@ -1443,29 +1585,18 @@
     int err, flags=0;
     DBObject* secondaryDB;
     PyObject* callback;
-#if (DBVER >= 41)
     PyObject *txnobj = NULL;
     DB_TXN *txn = NULL;
     static char* kwnames[] = {"secondaryDB", "callback", "flags", "txn",
                                     NULL};
-#else
-    static char* kwnames[] = {"secondaryDB", "callback", "flags", NULL};
-#endif
 
-#if (DBVER >= 41)
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|iO:associate", kwnames,
                                      &secondaryDB, &callback, &flags,
                                      &txnobj)) {
-#else
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|i:associate", kwnames,
-                                     &secondaryDB, &callback, &flags)) {
-#endif
         return NULL;
     }
 
-#if (DBVER >= 41)
     if (!checkTxnObj(txnobj, &txn)) return NULL;
-#endif
 
     CHECK_DB_NOT_CLOSED(self);
     if (!DBObject_Check(secondaryDB)) {
@@ -1501,18 +1632,11 @@
     PyEval_InitThreads();
 #endif
     MYDB_BEGIN_ALLOW_THREADS;
-#if (DBVER >= 41)
     err = self->db->associate(self->db,
                               txn,
                               secondaryDB->db,
                               _db_associateCallback,
                               flags);
-#else
-    err = self->db->associate(self->db,
-                              secondaryDB->db,
-                              _db_associateCallback,
-                              flags);
-#endif
     MYDB_END_ALLOW_THREADS;
 
     if (err) {
@@ -1546,12 +1670,10 @@
           Py_XDECREF(dummy);
         }
 
-#if (DBVER >= 43)
         while(self->children_sequences) {
             dummy=DBSequence_close_internal(self->children_sequences,0,0);
             Py_XDECREF(dummy);
         }
-#endif
 
         /*
         ** "do_not_close" is used to dispose all related objects in the
@@ -1705,6 +1827,64 @@
 }
 
 
+#if (DBVER >= 47)
+/*
+** This function is available since Berkeley DB 4.4,
+** but 4.6 version is so buggy that we only support
+** it from BDB 4.7 and newer.
+*/
+static PyObject*
+DB_compact(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    PyObject* txnobj = NULL;
+    PyObject *startobj = NULL, *stopobj = NULL;
+    int flags = 0;
+    DB_TXN *txn = NULL;
+    DBT *start_p = NULL, *stop_p = NULL;
+    DBT start, stop;
+    int err;
+    DB_COMPACT c_data = { 0 };
+    static char* kwnames[] = { "txn", "start", "stop", "flags",
+                               "compact_fillpercent", "compact_pages",
+                               "compact_timeout", NULL };
+
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOiiiI:compact", kwnames,
+                                     &txnobj, &startobj, &stopobj, &flags,
+                                     &c_data.compact_fillpercent,
+                                     &c_data.compact_pages,
+                                     &c_data.compact_timeout))
+        return NULL;
+
+    CHECK_DB_NOT_CLOSED(self);
+    if (!checkTxnObj(txnobj, &txn)) {
+        return NULL;
+    }
+
+    if (startobj && make_key_dbt(self, startobj, &start, NULL)) {
+        start_p = &start;
+    }
+    if (stopobj && make_key_dbt(self, stopobj, &stop, NULL)) {
+        stop_p = &stop;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->compact(self->db, txn, start_p, stop_p, &c_data,
+                            flags, NULL);
+    MYDB_END_ALLOW_THREADS;
+
+    if (startobj)
+        FREE_DBT(start);
+    if (stopobj)
+        FREE_DBT(stop);
+
+    RETURN_IF_ERR();
+
+    return PyLong_FromUnsignedLong(c_data.compact_pages_truncated);
+}
+#endif
+
+
 static PyObject*
 DB_fd(DBObject* self)
 {
@@ -1720,6 +1900,55 @@
 }
 
 
+#if (DBVER >= 46)
+static PyObject*
+DB_exists(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err, flags=0;
+    PyObject* txnobj = NULL;
+    PyObject* keyobj;
+    DBT key;
+    DB_TXN *txn;
+
+    static char* kwnames[] = {"key", "txn", "flags", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Oi:exists", kwnames,
+                &keyobj, &txnobj, &flags))
+        return NULL;
+
+    CHECK_DB_NOT_CLOSED(self);
+    if (!make_key_dbt(self, keyobj, &key, NULL))
+        return NULL;
+    if (!checkTxnObj(txnobj, &txn)) {
+        FREE_DBT(key);
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->exists(self->db, txn, &key, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    FREE_DBT(key);
+
+    if (!err) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    }
+    if ((err == DB_NOTFOUND || err == DB_KEYEMPTY)) {
+        Py_INCREF(Py_False);
+        return Py_False;
+    }
+
+    /*
+    ** If we reach there, there was an error. The
+    ** "return" should be unreachable.
+    */
+    RETURN_IF_ERR();
+    assert(0);  /* This coude SHOULD be unreachable */
+    return NULL;
+}
+#endif
+
 static PyObject*
 DB_get(DBObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -1861,20 +2090,12 @@
                 keyObj = NUMBER_FromLong(*(int *)key.data);
             else
                 keyObj = Build_PyString(key.data, key.size);
-#if (PY_VERSION_HEX >= 0x02040000)
             retval = PyTuple_Pack(3, keyObj, pkeyObj, dataObj);
-#else
-            retval = Py_BuildValue("OOO", keyObj, pkeyObj, dataObj);
-#endif
             Py_DECREF(keyObj);
         }
         else /* return just the pkey and data */
         {
-#if (PY_VERSION_HEX >= 0x02040000)
             retval = PyTuple_Pack(2, pkeyObj, dataObj);
-#else
-            retval = Py_BuildValue("OO", pkeyObj, dataObj);
-#endif
         }
         Py_DECREF(dataObj);
         Py_DECREF(pkeyObj);
@@ -1919,7 +2140,7 @@
     MYDB_BEGIN_ALLOW_THREADS;
     err = self->db->get(self->db, txn, &key, &data, flags);
     MYDB_END_ALLOW_THREADS;
-    if (err == DB_BUFFER_SMALL) {
+    if ((err == DB_BUFFER_SMALL) || (err == 0)) {
         retval = NUMBER_FromLong((long)data.size);
         err = 0;
     }
@@ -2118,7 +2339,6 @@
     int err, type = DB_UNKNOWN, flags=0, mode=0660;
     char* filename = NULL;
     char* dbname = NULL;
-#if (DBVER >= 41)
     PyObject *txnobj = NULL;
     DB_TXN *txn = NULL;
     /* with dbname */
@@ -2127,45 +2347,22 @@
     /* without dbname */
     static char* kwnames_basic[] = {
         "filename", "dbtype", "flags", "mode", "txn", NULL};
-#else
-    /* with dbname */
-    static char* kwnames[] = {
-        "filename", "dbname", "dbtype", "flags", "mode", NULL};
-    /* without dbname */
-    static char* kwnames_basic[] = {
-        "filename", "dbtype", "flags", "mode", NULL};
-#endif
 
-#if (DBVER >= 41)
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|ziiiO:open", kwnames,
                                      &filename, &dbname, &type, &flags, &mode,
                                      &txnobj))
-#else
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|ziii:open", kwnames,
-                                     &filename, &dbname, &type, &flags,
-                                     &mode))
-#endif
     {
         PyErr_Clear();
         type = DB_UNKNOWN; flags = 0; mode = 0660;
         filename = NULL; dbname = NULL;
-#if (DBVER >= 41)
         if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z|iiiO:open",
                                          kwnames_basic,
                                          &filename, &type, &flags, &mode,
                                          &txnobj))
             return NULL;
-#else
-        if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z|iii:open",
-                                         kwnames_basic,
-                                         &filename, &type, &flags, &mode))
-            return NULL;
-#endif
     }
 
-#if (DBVER >= 41)
     if (!checkTxnObj(txnobj, &txn)) return NULL;
-#endif
 
     if (NULL == self->db) {
         PyObject *t = Py_BuildValue("(is)", 0,
@@ -2177,24 +2374,17 @@
         return NULL;
     }
 
-#if (DBVER >= 41)
     if (txn) {  /* Can't use 'txnobj' because could be 'txnobj==Py_None' */
         INSERT_IN_DOUBLE_LINKED_LIST_TXN(((DBTxnObject *)txnobj)->children_dbs,self);
         self->txn=(DBTxnObject *)txnobj;
     } else {
         self->txn=NULL;
     }
-#else
-    self->txn=NULL;
-#endif
 
     MYDB_BEGIN_ALLOW_THREADS;
-#if (DBVER >= 41)
     err = self->db->open(self->db, txn, filename, dbname, type, flags, mode);
-#else
-    err = self->db->open(self->db, filename, dbname, type, flags, mode);
-#endif
     MYDB_END_ALLOW_THREADS;
+
     if (makeDBError(err)) {
         PyObject *dummy;
 
@@ -2203,9 +2393,7 @@
         return NULL;
     }
 
-#if (DBVER >= 42)
     self->db->get_flags(self->db, &self->setflags);
-#endif
 
     self->flags = flags;
 
@@ -2323,35 +2511,145 @@
     RETURN_NONE();
 }
 
-
+#if (DBVER >= 46)
 static PyObject*
-DB_set_bt_minkey(DBObject* self, PyObject* args)
+DB_set_priority(DBObject* self, PyObject* args)
 {
-    int err, minkey;
+    int err, priority;
 
-    if (!PyArg_ParseTuple(args,"i:set_bt_minkey", &minkey ))
+    if (!PyArg_ParseTuple(args,"i:set_priority", &priority))
         return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_bt_minkey(self->db, minkey);
+    err = self->db->set_priority(self->db, priority);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-static int
-_default_cmp(const DBT *leftKey,
-             const DBT *rightKey)
+static PyObject*
+DB_get_priority(DBObject* self)
 {
-  int res;
-  int lsize = leftKey->size, rsize = rightKey->size;
+    int err = 0;
+    DB_CACHE_PRIORITY priority;
 
-  res = memcmp(leftKey->data, rightKey->data,
-               lsize < rsize ? lsize : rsize);
+    CHECK_DB_NOT_CLOSED(self);
 
-  if (res == 0) {
-      if (lsize < rsize) {
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_priority(self->db, &priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(priority);
+}
+#endif
+
+static PyObject*
+DB_get_dbname(DBObject* self)
+{
+    int err;
+    const char *filename, *dbname;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_dbname(self->db, &filename, &dbname);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    /* If "dbname==NULL", it is correctly converted to "None" */
+    return Py_BuildValue("(ss)", filename, dbname);
+}
+
+static PyObject*
+DB_get_open_flags(DBObject* self)
+{
+    int err;
+    unsigned int flags;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_open_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+static PyObject*
+DB_set_q_extentsize(DBObject* self, PyObject* args)
+{
+    int err;
+    u_int32_t extentsize;
+
+    if (!PyArg_ParseTuple(args,"i:set_q_extentsize", &extentsize))
+        return NULL;
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->set_q_extentsize(self->db, extentsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DB_get_q_extentsize(DBObject* self)
+{
+    int err = 0;
+    u_int32_t extentsize;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_q_extentsize(self->db, &extentsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(extentsize);
+}
+
+static PyObject*
+DB_set_bt_minkey(DBObject* self, PyObject* args)
+{
+    int err, minkey;
+
+    if (!PyArg_ParseTuple(args,"i:set_bt_minkey", &minkey))
+        return NULL;
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->set_bt_minkey(self->db, minkey);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DB_get_bt_minkey(DBObject* self)
+{
+    int err;
+    u_int32_t bt_minkey;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_bt_minkey(self->db, &bt_minkey);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(bt_minkey);
+}
+
+static int
+_default_cmp(const DBT *leftKey,
+             const DBT *rightKey)
+{
+  int res;
+  int lsize = leftKey->size, rsize = rightKey->size;
+
+  res = memcmp(leftKey->data, rightKey->data,
+               lsize < rsize ? lsize : rsize);
+
+  if (res == 0) {
+      if (lsize < rsize) {
           res = -1;
       }
       else if (lsize > rsize) {
@@ -2475,6 +2773,120 @@
     RETURN_NONE();
 }
 
+static int
+_db_dupCompareCallback(DB* db,
+		    const DBT *leftKey,
+		    const DBT *rightKey)
+{
+    int res = 0;
+    PyObject *args;
+    PyObject *result = NULL;
+    DBObject *self = (DBObject *)db->app_private;
+
+    if (self == NULL || self->dupCompareCallback == NULL) {
+	MYDB_BEGIN_BLOCK_THREADS;
+	PyErr_SetString(PyExc_TypeError,
+			(self == 0
+			 ? "DB_dup_compare db is NULL."
+			 : "DB_dup_compare callback is NULL."));
+	/* we're in a callback within the DB code, we can't raise */
+	PyErr_Print();
+	res = _default_cmp(leftKey, rightKey);
+	MYDB_END_BLOCK_THREADS;
+    } else {
+	MYDB_BEGIN_BLOCK_THREADS;
+
+	args = BuildValue_SS(leftKey->data, leftKey->size, rightKey->data, rightKey->size);
+	if (args != NULL) {
+		result = PyEval_CallObject(self->dupCompareCallback, args);
+	}
+	if (args == NULL || result == NULL) {
+	    /* we're in a callback within the DB code, we can't raise */
+	    PyErr_Print();
+	    res = _default_cmp(leftKey, rightKey);
+	} else if (NUMBER_Check(result)) {
+	    res = NUMBER_AsLong(result);
+	} else {
+	    PyErr_SetString(PyExc_TypeError,
+			    "DB_dup_compare callback MUST return an int.");
+	    /* we're in a callback within the DB code, we can't raise */
+	    PyErr_Print();
+	    res = _default_cmp(leftKey, rightKey);
+	}
+
+	Py_XDECREF(args);
+	Py_XDECREF(result);
+
+	MYDB_END_BLOCK_THREADS;
+    }
+    return res;
+}
+
+static PyObject*
+DB_set_dup_compare(DBObject* self, PyObject* comparator)
+{
+    int err;
+    PyObject *tuple, *result;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    if (!PyCallable_Check(comparator)) {
+	makeTypeError("Callable", comparator);
+	return NULL;
+    }
+
+    /*
+     * Perform a test call of the comparator function with two empty
+     * string objects here.  verify that it returns an int (0).
+     * err if not.
+     */
+    tuple = Py_BuildValue("(ss)", "", "");
+    result = PyEval_CallObject(comparator, tuple);
+    Py_DECREF(tuple);
+    if (result == NULL)
+        return NULL;
+    if (!NUMBER_Check(result)) {
+	Py_DECREF(result);
+	PyErr_SetString(PyExc_TypeError,
+		        "callback MUST return an int");
+	return NULL;
+    } else if (NUMBER_AsLong(result) != 0) {
+	Py_DECREF(result);
+	PyErr_SetString(PyExc_TypeError,
+		        "callback failed to return 0 on two empty strings");
+	return NULL;
+    }
+    Py_DECREF(result);
+
+    /* We don't accept multiple set_dup_compare operations, in order to
+     * simplify the code. This would have no real use, as one cannot
+     * change the function once the db is opened anyway */
+    if (self->dupCompareCallback != NULL) {
+	PyErr_SetString(PyExc_RuntimeError, "set_dup_compare() cannot be called more than once");
+	return NULL;
+    }
+
+    Py_INCREF(comparator);
+    self->dupCompareCallback = comparator;
+
+    /* This is to workaround a problem with un-initialized threads (see
+       comment in DB_associate) */
+#ifdef WITH_THREAD
+    PyEval_InitThreads();
+#endif
+
+    err = self->db->set_dup_compare(self->db, _db_dupCompareCallback);
+
+    if (err) {
+	/* restore the old state in case of error */
+	Py_DECREF(comparator);
+	self->dupCompareCallback = NULL;
+    }
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
 
 static PyObject*
 DB_set_cachesize(DBObject* self, PyObject* args)
@@ -2494,6 +2906,23 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_cachesize(DBObject* self)
+{
+    int err;
+    u_int32_t gbytes, bytes;
+    int ncache;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_cachesize(self->db, &gbytes, &bytes, &ncache);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(iii)", gbytes, bytes, ncache);
+}
 
 static PyObject*
 DB_set_flags(DBObject* self, PyObject* args)
@@ -2513,6 +2942,48 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_flags(DBObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+static PyObject*
+DB_get_transactional(DBObject* self)
+{
+    int err;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_transactional(self->db);
+    MYDB_END_ALLOW_THREADS;
+
+    if(err == 0) {
+        Py_INCREF(Py_False);
+        return Py_False;
+    } else if(err == 1) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    }
+
+    /*
+    ** If we reach there, there was an error. The
+    ** "return" should be unreachable.
+    */
+    RETURN_IF_ERR();
+    assert(0);  /* This code SHOULD be unreachable */
+    return NULL;
+}
 
 static PyObject*
 DB_set_h_ffactor(DBObject* self, PyObject* args)
@@ -2530,6 +3001,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_h_ffactor(DBObject* self)
+{
+    int err;
+    u_int32_t ffactor;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_h_ffactor(self->db, &ffactor);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(ffactor);
+}
 
 static PyObject*
 DB_set_h_nelem(DBObject* self, PyObject* args)
@@ -2547,6 +3032,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_h_nelem(DBObject* self)
+{
+    int err;
+    u_int32_t nelem;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_h_nelem(self->db, &nelem);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(nelem);
+}
 
 static PyObject*
 DB_set_lorder(DBObject* self, PyObject* args)
@@ -2564,6 +3063,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_lorder(DBObject* self)
+{
+    int err;
+    int lorder;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_lorder(self->db, &lorder);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lorder);
+}
 
 static PyObject*
 DB_set_pagesize(DBObject* self, PyObject* args)
@@ -2581,6 +3094,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_pagesize(DBObject* self)
+{
+    int err;
+    u_int32_t pagesize;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_pagesize(self->db, &pagesize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(pagesize);
+}
 
 static PyObject*
 DB_set_re_delim(DBObject* self, PyObject* args)
@@ -2604,6 +3131,20 @@
 }
 
 static PyObject*
+DB_get_re_delim(DBObject* self)
+{
+    int err, re_delim;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_delim(self->db, &re_delim);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_delim);
+}
+
+static PyObject*
 DB_set_re_len(DBObject* self, PyObject* args)
 {
     int err, len;
@@ -2619,6 +3160,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DB_get_re_len(DBObject* self)
+{
+    int err;
+    u_int32_t re_len;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_len(self->db, &re_len);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_len);
+}
 
 static PyObject*
 DB_set_re_pad(DBObject* self, PyObject* args)
@@ -2640,40 +3195,50 @@
     RETURN_NONE();
 }
 
-
+static PyObject*
+DB_get_re_pad(DBObject* self)
+{
+    int err, re_pad;
+
+    CHECK_DB_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_re_pad(self->db, &re_pad);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(re_pad);
+}
+
 static PyObject*
 DB_set_re_source(DBObject* self, PyObject* args)
 {
     int err;
-    char *re_source;
+    char *source;
 
-    if (!PyArg_ParseTuple(args,"s:set_re_source", &re_source))
+    if (!PyArg_ParseTuple(args,"s:set_re_source", &source))
         return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_re_source(self->db, re_source);
+    err = self->db->set_re_source(self->db, source);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DB_set_q_extentsize(DBObject* self, PyObject* args)
+DB_get_re_source(DBObject* self)
 {
     int err;
-    int extentsize;
+    const char *source;
 
-    if (!PyArg_ParseTuple(args,"i:set_q_extentsize", &extentsize))
-        return NULL;
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->set_q_extentsize(self->db, extentsize);
+    err = self->db->get_re_source(self->db, &source);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return PyBytes_FromString(source);
 }
 
 static PyObject*
@@ -2682,37 +3247,22 @@
     int err, flags = 0, type;
     void* sp;
     PyObject* d;
-#if (DBVER >= 43)
     PyObject* txnobj = NULL;
     DB_TXN *txn = NULL;
     static char* kwnames[] = { "flags", "txn", NULL };
-#else
-    static char* kwnames[] = { "flags", NULL };
-#endif
 
-#if (DBVER >= 43)
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iO:stat", kwnames,
                                      &flags, &txnobj))
         return NULL;
     if (!checkTxnObj(txnobj, &txn))
         return NULL;
-#else
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat", kwnames, &flags))
-        return NULL;
-#endif
     CHECK_DB_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-#if (DBVER >= 43)
     err = self->db->stat(self->db, txn, &sp, flags);
-#else
-    err = self->db->stat(self->db, &sp, flags);
-#endif
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
 
-    self->haveStat = 1;
-
     /* Turn the stat structure into a dictionary */
     type = _DB_get_type(self);
     if ((type == -1) || ((d = PyDict_New()) == NULL)) {
@@ -2734,9 +3284,6 @@
         MAKE_HASH_ENTRY(pagecnt);
 #endif
         MAKE_HASH_ENTRY(pagesize);
-#if (DBVER < 41)
-        MAKE_HASH_ENTRY(nelem);
-#endif
         MAKE_HASH_ENTRY(ffactor);
         MAKE_HASH_ENTRY(buckets);
         MAKE_HASH_ENTRY(free);
@@ -2767,9 +3314,7 @@
         MAKE_BT_ENTRY(leaf_pg);
         MAKE_BT_ENTRY(dup_pg);
         MAKE_BT_ENTRY(over_pg);
-#if (DBVER >= 43)
         MAKE_BT_ENTRY(empty_pg);
-#endif
         MAKE_BT_ENTRY(free);
         MAKE_BT_ENTRY(int_pgfree);
         MAKE_BT_ENTRY(leaf_pgfree);
@@ -2783,9 +3328,7 @@
         MAKE_QUEUE_ENTRY(nkeys);
         MAKE_QUEUE_ENTRY(ndata);
         MAKE_QUEUE_ENTRY(pagesize);
-#if (DBVER >= 41)
         MAKE_QUEUE_ENTRY(extentsize);
-#endif
         MAKE_QUEUE_ENTRY(pages);
         MAKE_QUEUE_ENTRY(re_len);
         MAKE_QUEUE_ENTRY(re_pad);
@@ -2812,6 +3355,27 @@
 }
 
 static PyObject*
+DB_stat_print(DBObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_DB_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->stat_print(self->db, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
 DB_sync(DBObject* self, PyObject* args)
 {
     int err;
@@ -2896,7 +3460,7 @@
         PyObject *error;
 
         error=DB_close_internal(self, 0, 1);
-        if (error ) {
+        if (error) {
           return error;
         }
      }
@@ -2934,7 +3498,6 @@
     return NUMBER_FromLong(oldValue);
 }
 
-#if (DBVER >= 41)
 static PyObject*
 DB_set_encrypt(DBObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -2955,7 +3518,22 @@
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif /* DBVER >= 41 */
+
+static PyObject*
+DB_get_encrypt_flags(DBObject* self)
+{
+    int err;
+    u_int32_t flags;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db->get_encrypt_flags(self->db, &flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(flags);
+}
+
 
 
 /*-------------------------------------------------------------- */
@@ -2965,7 +3543,6 @@
 {
     int err;
     Py_ssize_t size = 0;
-    int flags = 0;
     void* sp;
     DBObject* self = (DBObject*)_self;
 
@@ -2978,41 +3555,17 @@
         return -1;
     }
 
-    if (self->haveStat) {  /* Has the stat function been called recently?  If
-                              so, we can use the cached value. */
-        flags = DB_FAST_STAT;
-    }
-
     MYDB_BEGIN_ALLOW_THREADS;
-redo_stat_for_length:
-#if (DBVER >= 43)
-    err = self->db->stat(self->db, /*txnid*/ NULL, &sp, flags);
-#else
-    err = self->db->stat(self->db, &sp, flags);
-#endif
+    err = self->db->stat(self->db, /*txnid*/ NULL, &sp, 0);
+    MYDB_END_ALLOW_THREADS;
 
     /* All the stat structures have matching fields upto the ndata field,
        so we can use any of them for the type cast */
     size = ((DB_BTREE_STAT*)sp)->bt_ndata;
 
-    /* A size of 0 could mean that Berkeley DB no longer had the stat values cached.
-     * redo a full stat to make sure.
-     *   Fixes SF python bug 1493322, pybsddb bug 1184012
-     */
-    if (size == 0 && (flags & DB_FAST_STAT)) {
-        flags = 0;
-        if (!err)
-            free(sp);
-        goto redo_stat_for_length;
-    }
-
-    MYDB_END_ALLOW_THREADS;
-
     if (err)
         return -1;
 
-    self->haveStat = 1;
-
     free(sp);
     return size;
 }
@@ -3101,18 +3654,11 @@
 
 
 static PyObject*
-DB_has_key(DBObject* self, PyObject* args, PyObject* kwargs)
+_DB_has_key(DBObject* self, PyObject* keyobj, PyObject* txnobj)
 {
     int err;
-    PyObject* keyobj;
-    DBT key, data;
-    PyObject* txnobj = NULL;
+    DBT key;
     DB_TXN *txn = NULL;
-    static char* kwnames[] = {"key","txn", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:has_key", kwnames,
-                &keyobj, &txnobj))
-        return NULL;
 
     CHECK_DB_NOT_CLOSED(self);
     if (!make_key_dbt(self, keyobj, &key, NULL))
@@ -3122,28 +3668,77 @@
         return NULL;
     }
 
+#if (DBVER < 46)
     /* This causes DB_BUFFER_SMALL to be returned when the db has the key because
        it has a record but can't allocate a buffer for the data.  This saves
        having to deal with data we won't be using.
      */
-    CLEAR_DBT(data);
-    data.flags = DB_DBT_USERMEM;
+    {
+        DBT data ;
+        CLEAR_DBT(data);
+        data.flags = DB_DBT_USERMEM;
 
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->db->get(self->db, txn, &key, &data, 0);
+        MYDB_END_ALLOW_THREADS;
+    }
+#else
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db->get(self->db, txn, &key, &data, 0);
+    err = self->db->exists(self->db, txn, &key, 0);
     MYDB_END_ALLOW_THREADS;
+#endif
+
     FREE_DBT(key);
 
+    /*
+    ** DB_BUFFER_SMALL is only used if we use "get".
+    ** We can drop it when we only use "exists",
+    ** when we drop suport for Berkeley DB < 4.6.
+    */
     if (err == DB_BUFFER_SMALL || err == 0) {
-        return NUMBER_FromLong(1);
+        Py_INCREF(Py_True);
+        return Py_True;
     } else if (err == DB_NOTFOUND || err == DB_KEYEMPTY) {
-        return NUMBER_FromLong(0);
+        Py_INCREF(Py_False);
+        return Py_False;
     }
 
     makeDBError(err);
     return NULL;
 }
 
+static PyObject*
+DB_has_key(DBObject* self, PyObject* args, PyObject* kwargs)
+{
+    PyObject* keyobj;
+    PyObject* txnobj = NULL;
+    static char* kwnames[] = {"key","txn", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:has_key", kwnames,
+                &keyobj, &txnobj))
+        return NULL;
+
+    return _DB_has_key(self, keyobj, txnobj);
+}
+
+
+static int DB_contains(DBObject* self, PyObject* keyobj)
+{
+    PyObject* result;
+    int result2 = 0;
+
+    result = _DB_has_key(self, keyobj, NULL) ;
+    if (result == NULL) {
+        return -1; /* Propague exception */
+    }
+    if (result != Py_False) {
+        result2 = 1;
+    }
+
+    Py_DECREF(result);
+    return result2;
+}
+
 
 #define _KEYS_LIST      1
 #define _VALUES_LIST    2
@@ -3297,113 +3892,352 @@
 }
 
 /* --------------------------------------------------------------------- */
-/* DBCursor methods */
+/* DBLogCursor methods */
 
 
 static PyObject*
-DBC_close_internal(DBCursorObject* self)
+DBLogCursor_close_internal(DBLogCursorObject* self)
 {
     int err = 0;
 
-    if (self->dbc != NULL) {
+    if (self->logc != NULL) {
         EXTRACT_FROM_DOUBLE_LINKED_LIST(self);
-        if (self->txn) {
-            EXTRACT_FROM_DOUBLE_LINKED_LIST_TXN(self);
-            self->txn=NULL;
-        }
 
         MYDB_BEGIN_ALLOW_THREADS;
-        err = _DBC_close(self->dbc);
+        err = self->logc->close(self->logc, 0);
         MYDB_END_ALLOW_THREADS;
-        self->dbc = NULL;
+        self->logc = NULL;
     }
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
 static PyObject*
-DBC_close(DBCursorObject* self)
+DBLogCursor_close(DBLogCursorObject* self)
 {
-    return DBC_close_internal(self);
+    return DBLogCursor_close_internal(self);
 }
 
 
 static PyObject*
-DBC_count(DBCursorObject* self, PyObject* args)
+_DBLogCursor_get(DBLogCursorObject* self, int flag, DB_LSN *lsn2)
 {
-    int err = 0;
-    db_recno_t count;
-    int flags = 0;
+    int err;
+    DBT data;
+    DB_LSN lsn = {0, 0};
+    PyObject *dummy, *retval;
 
-    if (!PyArg_ParseTuple(args, "|i:count", &flags))
-        return NULL;
+    CLEAR_DBT(data);
+    data.flags = DB_DBT_MALLOC; /* Berkeley DB must do the malloc */
 
-    CHECK_CURSOR_NOT_CLOSED(self);
+    CHECK_LOGCURSOR_NOT_CLOSED(self);
+
+    if (lsn2)
+        lsn = *lsn2;
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = _DBC_count(self->dbc, &count, flags);
+    err = self->logc->get(self->logc, &lsn, &data, flag);
     MYDB_END_ALLOW_THREADS;
-    RETURN_IF_ERR();
 
-    return NUMBER_FromLong(count);
+    if (err == DB_NOTFOUND) {
+        Py_INCREF(Py_None);
+        retval = Py_None;
+    }
+    else if (makeDBError(err)) {
+        retval = NULL;
+    }
+    else {
+        retval = dummy = BuildValue_S(data.data, data.size);
+        if (dummy) {
+            retval = Py_BuildValue("(ii)O", lsn.file, lsn.offset, dummy);
+            Py_DECREF(dummy);
+        }
+    }
+
+    FREE_DBT(data);
+    return retval;
 }
 
+static PyObject*
+DBLogCursor_current(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_CURRENT, NULL);
+}
 
 static PyObject*
-DBC_current(DBCursorObject* self, PyObject* args, PyObject *kwargs)
+DBLogCursor_first(DBLogCursorObject* self)
 {
-    return _DBCursor_get(self,DB_CURRENT,args,kwargs,"|iii:current");
+    return _DBLogCursor_get(self, DB_FIRST, NULL);
+}
+
+static PyObject*
+DBLogCursor_last(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_LAST, NULL);
 }
 
+static PyObject*
+DBLogCursor_next(DBLogCursorObject* self)
+{
+    return _DBLogCursor_get(self, DB_NEXT, NULL);
+}
 
 static PyObject*
-DBC_delete(DBCursorObject* self, PyObject* args)
+DBLogCursor_prev(DBLogCursorObject* self)
 {
-    int err, flags=0;
+    return _DBLogCursor_get(self, DB_PREV, NULL);
+}
 
-    if (!PyArg_ParseTuple(args, "|i:delete", &flags))
+static PyObject*
+DBLogCursor_set(DBLogCursorObject* self, PyObject* args)
+{
+    DB_LSN lsn;
+
+    if (!PyArg_ParseTuple(args, "(ii):set", &lsn.file, &lsn.offset))
         return NULL;
 
-    CHECK_CURSOR_NOT_CLOSED(self);
+    return _DBLogCursor_get(self, DB_SET, &lsn);
+}
+
+
+/* --------------------------------------------------------------------- */
+/* DBSite methods */
+
+
+#if (DBVER >= 52)
+static PyObject*
+DBSite_close_internal(DBSiteObject* self)
+{
+    int err = 0;
+
+    if (self->site != NULL) {
+        EXTRACT_FROM_DOUBLE_LINKED_LIST(self);
+
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->site->close(self->site);
+        MYDB_END_ALLOW_THREADS;
+        self->site = NULL;
+    }
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBSite_close(DBSiteObject* self)
+{
+    return DBSite_close_internal(self);
+}
+
+static PyObject*
+DBSite_remove(DBSiteObject* self)
+{
+    int err = 0;
+
+    CHECK_SITE_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = _DBC_del(self->dbc, flags);
+    err = self->site->remove(self->site);
     MYDB_END_ALLOW_THREADS;
-    RETURN_IF_ERR();
 
-    self->mydb->haveStat = 0;
+    RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBSite_get_eid(DBSiteObject* self)
+{
+    int err = 0;
+    int eid;
+
+    CHECK_SITE_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->site->get_eid(self->site, &eid);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(eid);
+}
 
 static PyObject*
-DBC_dup(DBCursorObject* self, PyObject* args)
+DBSite_get_address(DBSiteObject* self)
 {
-    int err, flags =0;
-    DBC* dbc = NULL;
+    int err = 0;
+    const char *host;
+    u_int port;
 
-    if (!PyArg_ParseTuple(args, "|i:dup", &flags))
+    CHECK_SITE_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->site->get_address(self->site, &host, &port);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return Py_BuildValue("(sI)", host, port);
+}
+
+static PyObject*
+DBSite_get_config(DBSiteObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err = 0;
+    u_int32_t which, value;
+    static char* kwnames[] = { "which", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:get_config", kwnames,
+                                     &which))
         return NULL;
 
-    CHECK_CURSOR_NOT_CLOSED(self);
+    CHECK_SITE_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = _DBC_dup(self->dbc, &dbc, flags);
+    err = self->site->get_config(self->site, which, &value);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
 
-    return (PyObject*) newDBCursorObject(dbc, self->txn, self->mydb);
+    if (value) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    } else {
+        Py_INCREF(Py_False);
+        return Py_False;
+    }
 }
 
 static PyObject*
-DBC_first(DBCursorObject* self, PyObject* args, PyObject* kwargs)
+DBSite_set_config(DBSiteObject* self, PyObject* args, PyObject* kwargs)
 {
-    return _DBCursor_get(self,DB_FIRST,args,kwargs,"|iii:first");
+    int err = 0;
+    u_int32_t which, value;
+    PyObject *valueO;
+    static char* kwnames[] = { "which", "value", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:set_config", kwnames,
+                                     &which, &valueO))
+        return NULL;
+
+    CHECK_SITE_NOT_CLOSED(self);
+
+    value = PyObject_IsTrue(valueO);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->site->set_config(self->site, which, value);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
 }
+#endif
+
+
+/* --------------------------------------------------------------------- */
+/* DBCursor methods */
 
 
 static PyObject*
-DBC_get(DBCursorObject* self, PyObject* args, PyObject *kwargs)
+DBC_close_internal(DBCursorObject* self)
+{
+    int err = 0;
+
+    if (self->dbc != NULL) {
+        EXTRACT_FROM_DOUBLE_LINKED_LIST(self);
+        if (self->txn) {
+            EXTRACT_FROM_DOUBLE_LINKED_LIST_TXN(self);
+            self->txn=NULL;
+        }
+
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = _DBC_close(self->dbc);
+        MYDB_END_ALLOW_THREADS;
+        self->dbc = NULL;
+    }
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBC_close(DBCursorObject* self)
+{
+    return DBC_close_internal(self);
+}
+
+
+static PyObject*
+DBC_count(DBCursorObject* self, PyObject* args)
+{
+    int err = 0;
+    db_recno_t count;
+    int flags = 0;
+
+    if (!PyArg_ParseTuple(args, "|i:count", &flags))
+        return NULL;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = _DBC_count(self->dbc, &count, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(count);
+}
+
+
+static PyObject*
+DBC_current(DBCursorObject* self, PyObject* args, PyObject *kwargs)
+{
+    return _DBCursor_get(self,DB_CURRENT,args,kwargs,"|iii:current");
+}
+
+
+static PyObject*
+DBC_delete(DBCursorObject* self, PyObject* args)
+{
+    int err, flags=0;
+
+    if (!PyArg_ParseTuple(args, "|i:delete", &flags))
+        return NULL;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = _DBC_del(self->dbc, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBC_dup(DBCursorObject* self, PyObject* args)
+{
+    int err, flags =0;
+    DBC* dbc = NULL;
+
+    if (!PyArg_ParseTuple(args, "|i:dup", &flags))
+        return NULL;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = _DBC_dup(self->dbc, &dbc, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    return (PyObject*) newDBCursorObject(dbc, self->txn, self->mydb);
+}
+
+static PyObject*
+DBC_first(DBCursorObject* self, PyObject* args, PyObject* kwargs)
+{
+    return _DBCursor_get(self,DB_FIRST,args,kwargs,"|iii:first");
+}
+
+
+static PyObject*
+DBC_get(DBCursorObject* self, PyObject* args, PyObject *kwargs)
 {
     int err, flags=0;
     PyObject* keyobj = NULL;
@@ -3555,21 +4389,13 @@
                 keyObj = NUMBER_FromLong(*(int *)key.data);
             else
                 keyObj = Build_PyString(key.data, key.size);
-#if (PY_VERSION_HEX >= 0x02040000)
             retval = PyTuple_Pack(3, keyObj, pkeyObj, dataObj);
-#else
-            retval = Py_BuildValue("OOO", keyObj, pkeyObj, dataObj);
-#endif
             Py_DECREF(keyObj);
             FREE_DBT(key);  /* 'make_key_dbt' could do a 'malloc' */
         }
         else /* return just the pkey and data */
         {
-#if (PY_VERSION_HEX >= 0x02040000)
             retval = PyTuple_Pack(2, pkeyObj, dataObj);
-#else
-            retval = Py_BuildValue("OO", pkeyObj, dataObj);
-#endif
         }
         Py_DECREF(dataObj);
         Py_DECREF(pkeyObj);
@@ -3659,7 +4485,6 @@
     MYDB_END_ALLOW_THREADS;
     FREE_DBT(key);  /* 'make_key_dbt' could do a 'malloc' */
     RETURN_IF_ERR();
-    self->mydb->haveStat = 0;
     RETURN_NONE();
 }
 
@@ -3974,6 +4799,13 @@
     return _DBCursor_get(self,DB_NEXT_NODUP,args,kwargs,"|iii:next_nodup");
 }
 
+#if (DBVER >= 46)
+static PyObject*
+DBC_prev_dup(DBCursorObject* self, PyObject* args, PyObject *kwargs)
+{
+    return _DBCursor_get(self,DB_PREV_DUP,args,kwargs,"|iii:prev_dup");
+}
+#endif
 
 static PyObject*
 DBC_prev_nodup(DBCursorObject* self, PyObject* args, PyObject *kwargs)
@@ -4016,6 +4848,44 @@
 }
 
 
+#if (DBVER >= 46)
+static PyObject*
+DBC_set_priority(DBCursorObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err, priority;
+    static char* kwnames[] = { "priority", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:set_priority", kwnames,
+                                     &priority))
+        return NULL;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->dbc->set_priority(self->dbc, priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBC_get_priority(DBCursorObject* self)
+{
+    int err;
+    DB_CACHE_PRIORITY priority;
+
+    CHECK_CURSOR_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->dbc->get_priority(self->dbc, &priority);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(priority);
+}
+#endif
+
+
 
 /* --------------------------------------------------------------------- */
 /* DBEnv methods */
@@ -4029,13 +4899,23 @@
 
     if (!self->closed) {      /* Don't close more than once */
         while(self->children_txns) {
-          dummy=DBTxn_abort_discard_internal(self->children_txns,0);
-          Py_XDECREF(dummy);
+            dummy = DBTxn_abort_discard_internal(self->children_txns, 0);
+            Py_XDECREF(dummy);
         }
         while(self->children_dbs) {
-          dummy=DB_close_internal(self->children_dbs, 0, 0);
-          Py_XDECREF(dummy);
+            dummy = DB_close_internal(self->children_dbs, 0, 0);
+            Py_XDECREF(dummy);
         }
+        while(self->children_logcursors) {
+            dummy = DBLogCursor_close_internal(self->children_logcursors);
+            Py_XDECREF(dummy);
+        }
+#if (DBVER >= 52)
+        while(self->children_sites) {
+            dummy = DBSite_close_internal(self->children_sites);
+            Py_XDECREF(dummy);
+        }
+#endif
     }
 
     self->closed = 1;
@@ -4084,6 +4964,192 @@
 
 
 static PyObject*
+DBEnv_memp_stat(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    DB_MPOOL_STAT *gsp;
+    DB_MPOOL_FSTAT **fsp, **fsp2;
+    PyObject* d = NULL, *d2, *d3, *r;
+    u_int32_t flags = 0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:memp_stat",
+                kwnames, &flags))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_stat(self->db_env, &gsp, &fsp, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    /* Turn the stat structure into a dictionary */
+    d = PyDict_New();
+    if (d == NULL) {
+        if (gsp)
+            free(gsp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(d, #name, gsp->st_##name)
+
+    MAKE_ENTRY(gbytes);
+    MAKE_ENTRY(bytes);
+    MAKE_ENTRY(ncache);
+#if (DBVER >= 46)
+    MAKE_ENTRY(max_ncache);
+#endif
+    MAKE_ENTRY(regsize);
+    MAKE_ENTRY(mmapsize);
+    MAKE_ENTRY(maxopenfd);
+    MAKE_ENTRY(maxwrite);
+    MAKE_ENTRY(maxwrite_sleep);
+    MAKE_ENTRY(map);
+    MAKE_ENTRY(cache_hit);
+    MAKE_ENTRY(cache_miss);
+    MAKE_ENTRY(page_create);
+    MAKE_ENTRY(page_in);
+    MAKE_ENTRY(page_out);
+    MAKE_ENTRY(ro_evict);
+    MAKE_ENTRY(rw_evict);
+    MAKE_ENTRY(page_trickle);
+    MAKE_ENTRY(pages);
+    MAKE_ENTRY(page_clean);
+    MAKE_ENTRY(page_dirty);
+    MAKE_ENTRY(hash_buckets);
+    MAKE_ENTRY(hash_searches);
+    MAKE_ENTRY(hash_longest);
+    MAKE_ENTRY(hash_examined);
+    MAKE_ENTRY(hash_nowait);
+    MAKE_ENTRY(hash_wait);
+#if (DBVER >= 45)
+    MAKE_ENTRY(hash_max_nowait);
+#endif
+    MAKE_ENTRY(hash_max_wait);
+    MAKE_ENTRY(region_wait);
+    MAKE_ENTRY(region_nowait);
+#if (DBVER >= 45)
+    MAKE_ENTRY(mvcc_frozen);
+    MAKE_ENTRY(mvcc_thawed);
+    MAKE_ENTRY(mvcc_freed);
+#endif
+    MAKE_ENTRY(alloc);
+    MAKE_ENTRY(alloc_buckets);
+    MAKE_ENTRY(alloc_max_buckets);
+    MAKE_ENTRY(alloc_pages);
+    MAKE_ENTRY(alloc_max_pages);
+#if (DBVER >= 45)
+    MAKE_ENTRY(io_wait);
+#endif
+#if (DBVER >= 48)
+    MAKE_ENTRY(sync_interrupted);
+#endif
+
+#undef MAKE_ENTRY
+    free(gsp);
+
+    d2 = PyDict_New();
+    if (d2 == NULL) {
+        Py_DECREF(d);
+        if (fsp)
+            free(fsp);
+        return NULL;
+    }
+#define MAKE_ENTRY(name)  _addIntToDict(d3, #name, (*fsp2)->st_##name)
+    for(fsp2=fsp;*fsp2; fsp2++) {
+        d3 = PyDict_New();
+        if (d3 == NULL) {
+            Py_DECREF(d);
+            Py_DECREF(d2);
+            if (fsp)
+                free(fsp);
+            return NULL;
+        }
+        MAKE_ENTRY(pagesize);
+        MAKE_ENTRY(cache_hit);
+        MAKE_ENTRY(cache_miss);
+        MAKE_ENTRY(map);
+        MAKE_ENTRY(page_create);
+        MAKE_ENTRY(page_in);
+        MAKE_ENTRY(page_out);
+        if(PyDict_SetItemString(d2, (*fsp2)->file_name, d3)) {
+            Py_DECREF(d);
+            Py_DECREF(d2);
+            Py_DECREF(d3);
+            if (fsp)
+                free(fsp);
+            return NULL;
+        }
+        Py_DECREF(d3);
+    }
+
+#undef MAKE_ENTRY
+    free(fsp);
+
+    r = PyTuple_Pack(2, d, d2);
+    Py_DECREF(d);
+    Py_DECREF(d2);
+    return r;
+}
+
+static PyObject*
+DBEnv_memp_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:memp_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBEnv_memp_trickle(DBEnvObject* self, PyObject* args)
+{
+    int err, percent, nwrotep;
+
+    if (!PyArg_ParseTuple(args, "i:memp_trickle", &percent))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_trickle(self->db_env, percent, &nwrotep);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(nwrotep);
+}
+
+static PyObject*
+DBEnv_memp_sync(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_LSN lsn = {0, 0};
+    DB_LSN *lsn_p = NULL;
+
+    if (!PyArg_ParseTuple(args, "|(ii):memp_sync", &lsn.file, &lsn.offset))
+        return NULL;
+    if ((lsn.file!=0) || (lsn.offset!=0)) {
+        lsn_p = &lsn;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->memp_sync(self->db_env, lsn_p);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
 DBEnv_remove(DBEnvObject* self, PyObject* args)
 {
     int err, flags=0;
@@ -4099,7 +5165,6 @@
     RETURN_NONE();
 }
 
-#if (DBVER >= 41)
 static PyObject*
 DBEnv_dbremove(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -4156,6 +5221,8 @@
     RETURN_NONE();
 }
 
+
+
 static PyObject*
 DBEnv_set_encrypt(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -4176,351 +5243,900 @@
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif /* DBVER >= 41 */
 
 static PyObject*
-DBEnv_set_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_get_encrypt_flags(DBEnvObject* self)
 {
     int err;
-    u_int32_t flags=0;
-    u_int32_t timeout = 0;
-    static char* kwnames[] = { "timeout", "flags", NULL };
+    u_int32_t flags;
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
-                &timeout, &flags)) {
-        return NULL;
-    }
+    CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_timeout(self->db_env, (db_timeout_t)timeout, flags);
+    err = self->db_env->get_encrypt_flags(self->db_env, &flags);
     MYDB_END_ALLOW_THREADS;
 
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    return NUMBER_FromLong(flags);
 }
 
 static PyObject*
-DBEnv_set_shm_key(DBEnvObject* self, PyObject* args)
+DBEnv_get_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
     int err;
-    long shm_key = 0;
+    int flag;
+    u_int32_t timeout;
+    static char* kwnames[] = {"flag", NULL };
 
-    if (!PyArg_ParseTuple(args, "l:set_shm_key", &shm_key))
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:get_timeout", kwnames,
+                &flag)) {
         return NULL;
+    }
     CHECK_ENV_NOT_CLOSED(self);
 
-    err = self->db_env->set_shm_key(self->db_env, shm_key);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_timeout(self->db_env, &timeout, flag);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return NUMBER_FromLong(timeout);
 }
 
+
 static PyObject*
-DBEnv_set_cachesize(DBEnvObject* self, PyObject* args)
+DBEnv_set_timeout(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
-    int err, gbytes=0, bytes=0, ncache=0;
+    int err;
+    u_int32_t flags=0;
+    u_int32_t timeout = 0;
+    static char* kwnames[] = { "timeout", "flags", NULL };
 
-    if (!PyArg_ParseTuple(args, "ii|i:set_cachesize",
-                          &gbytes, &bytes, &ncache))
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
+                &timeout, &flags)) {
         return NULL;
-    CHECK_ENV_NOT_CLOSED(self);
+    }
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_cachesize(self->db_env, gbytes, bytes, ncache);
+    err = self->db_env->set_timeout(self->db_env, (db_timeout_t)timeout, flags);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DBEnv_set_flags(DBEnvObject* self, PyObject* args)
+DBEnv_set_shm_key(DBEnvObject* self, PyObject* args)
 {
-    int err, flags=0, onoff=0;
+    int err;
+    long shm_key = 0;
 
-    if (!PyArg_ParseTuple(args, "ii:set_flags",
-                          &flags, &onoff))
+    if (!PyArg_ParseTuple(args, "l:set_shm_key", &shm_key))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
-    MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_flags(self->db_env, flags, onoff);
-    MYDB_END_ALLOW_THREADS;
+    err = self->db_env->set_shm_key(self->db_env, shm_key);
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_shm_key(DBEnvObject* self)
+{
+    int err;
+    long shm_key;
+
+    CHECK_ENV_NOT_CLOSED(self);
 
-#if (DBVER >= 47)
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_shm_key(self->db_env, &shm_key);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(shm_key);
+}
+
+#if (DBVER >= 46)
 static PyObject*
-DBEnv_log_set_config(DBEnvObject* self, PyObject* args)
+DBEnv_set_cache_max(DBEnvObject* self, PyObject* args)
 {
-    int err, flags, onoff;
+    int err, gbytes, bytes;
 
-    if (!PyArg_ParseTuple(args, "ii:log_set_config",
-                          &flags, &onoff))
+    if (!PyArg_ParseTuple(args, "ii:set_cache_max",
+                          &gbytes, &bytes))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->log_set_config(self->db_env, flags, onoff);
+    err = self->db_env->set_cache_max(self->db_env, gbytes, bytes);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif /* DBVER >= 47 */
-
 
 static PyObject*
-DBEnv_set_data_dir(DBEnvObject* self, PyObject* args)
+DBEnv_get_cache_max(DBEnvObject* self)
 {
     int err;
-    char *dir;
+    u_int32_t gbytes, bytes;
 
-    if (!PyArg_ParseTuple(args, "s:set_data_dir", &dir))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_data_dir(self->db_env, dir);
+    err = self->db_env->get_cache_max(self->db_env, &gbytes, &bytes);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
-    RETURN_NONE();
-}
 
+    return Py_BuildValue("(ii)", gbytes, bytes);
+}
+#endif
 
+#if (DBVER >= 46)
 static PyObject*
-DBEnv_set_lg_bsize(DBEnvObject* self, PyObject* args)
+DBEnv_set_thread_count(DBEnvObject* self, PyObject* args)
 {
-    int err, lg_bsize;
+    int err;
+    u_int32_t count;
 
-    if (!PyArg_ParseTuple(args, "i:set_lg_bsize", &lg_bsize))
+    if (!PyArg_ParseTuple(args, "i:set_thread_count", &count))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lg_bsize(self->db_env, lg_bsize);
+    err = self->db_env->set_thread_count(self->db_env, count);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DBEnv_set_lg_dir(DBEnvObject* self, PyObject* args)
+DBEnv_get_thread_count(DBEnvObject* self)
 {
     int err;
-    char *dir;
+    u_int32_t count;
 
-    if (!PyArg_ParseTuple(args, "s:set_lg_dir", &dir))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lg_dir(self->db_env, dir);
+    err = self->db_env->get_thread_count(self->db_env, &count);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return NUMBER_FromLong(count);
 }
+#endif
 
 static PyObject*
-DBEnv_set_lg_max(DBEnvObject* self, PyObject* args)
+DBEnv_set_cachesize(DBEnvObject* self, PyObject* args)
 {
-    int err, lg_max;
+    int err, gbytes=0, bytes=0, ncache=0;
 
-    if (!PyArg_ParseTuple(args, "i:set_lg_max", &lg_max))
+    if (!PyArg_ParseTuple(args, "ii|i:set_cachesize",
+                          &gbytes, &bytes, &ncache))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lg_max(self->db_env, lg_max);
+    err = self->db_env->set_cachesize(self->db_env, gbytes, bytes, ncache);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-#if (DBVER >= 42)
 static PyObject*
-DBEnv_get_lg_max(DBEnvObject* self)
+DBEnv_get_cachesize(DBEnvObject* self)
 {
     int err;
-    u_int32_t lg_max;
+    u_int32_t gbytes, bytes;
+    int ncache;
 
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->get_lg_max(self->db_env, &lg_max);
+    err = self->db_env->get_cachesize(self->db_env, &gbytes, &bytes, &ncache);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
-    return NUMBER_FromLong(lg_max);
+
+    return Py_BuildValue("(iii)", gbytes, bytes, ncache);
 }
-#endif
 
 
 static PyObject*
-DBEnv_set_lg_regionmax(DBEnvObject* self, PyObject* args)
+DBEnv_set_flags(DBEnvObject* self, PyObject* args)
 {
-    int err, lg_max;
+    int err, flags=0, onoff=0;
 
-    if (!PyArg_ParseTuple(args, "i:set_lg_regionmax", &lg_max))
+    if (!PyArg_ParseTuple(args, "ii:set_flags",
+                          &flags, &onoff))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lg_regionmax(self->db_env, lg_max);
+    err = self->db_env->set_flags(self->db_env, flags, onoff);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DBEnv_set_lk_detect(DBEnvObject* self, PyObject* args)
+DBEnv_get_flags(DBEnvObject* self)
 {
-    int err, lk_detect;
+    int err;
+    u_int32_t flags;
 
-    if (!PyArg_ParseTuple(args, "i:set_lk_detect", &lk_detect))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lk_detect(self->db_env, lk_detect);
+    err = self->db_env->get_flags(self->db_env, &flags);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+    return NUMBER_FromLong(flags);
 }
 
-
-#if (DBVER < 45)
+#if (DBVER >= 47)
 static PyObject*
-DBEnv_set_lk_max(DBEnvObject* self, PyObject* args)
+DBEnv_log_set_config(DBEnvObject* self, PyObject* args)
 {
-    int err, max;
+    int err, flags, onoff;
 
-    if (!PyArg_ParseTuple(args, "i:set_lk_max", &max))
+    if (!PyArg_ParseTuple(args, "ii:log_set_config",
+                          &flags, &onoff))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lk_max(self->db_env, max);
+    err = self->db_env->log_set_config(self->db_env, flags, onoff);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
-#endif
 
+static PyObject*
+DBEnv_log_get_config(DBEnvObject* self, PyObject* args)
+{
+    int err, flag, onoff;
+
+    if (!PyArg_ParseTuple(args, "i:log_get_config", &flag))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
 
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_get_config(self->db_env, flag, &onoff);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyBool_FromLong(onoff);
+}
+#endif /* DBVER >= 47 */
 
+#if (DBVER >= 44)
 static PyObject*
-DBEnv_set_lk_max_locks(DBEnvObject* self, PyObject* args)
+DBEnv_mutex_set_max(DBEnvObject* self, PyObject* args)
 {
-    int err, max;
+    int err;
+    int value;
 
-    if (!PyArg_ParseTuple(args, "i:set_lk_max_locks", &max))
+    if (!PyArg_ParseTuple(args, "i:mutex_set_max", &value))
         return NULL;
+
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lk_max_locks(self->db_env, max);
+    err = self->db_env->mutex_set_max(self->db_env, value);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_mutex_get_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t value;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_max(self->db_env, &value);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(value);
+}
 
 static PyObject*
-DBEnv_set_lk_max_lockers(DBEnvObject* self, PyObject* args)
+DBEnv_mutex_set_align(DBEnvObject* self, PyObject* args)
 {
-    int err, max;
+    int err;
+    int align;
 
-    if (!PyArg_ParseTuple(args, "i:set_lk_max_lockers", &max))
+    if (!PyArg_ParseTuple(args, "i:mutex_set_align", &align))
         return NULL;
+
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lk_max_lockers(self->db_env, max);
+    err = self->db_env->mutex_set_align(self->db_env, align);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_mutex_get_align(DBEnvObject* self)
+{
+    int err;
+    u_int32_t align;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_align(self->db_env, &align);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(align);
+}
 
 static PyObject*
-DBEnv_set_lk_max_objects(DBEnvObject* self, PyObject* args)
+DBEnv_mutex_set_increment(DBEnvObject* self, PyObject* args)
 {
-    int err, max;
+    int err;
+    int increment;
 
-    if (!PyArg_ParseTuple(args, "i:set_lk_max_objects", &max))
+    if (!PyArg_ParseTuple(args, "i:mutex_set_increment", &increment))
         return NULL;
+
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_lk_max_objects(self->db_env, max);
+    err = self->db_env->mutex_set_increment(self->db_env, increment);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_mutex_get_increment(DBEnvObject* self)
+{
+    int err;
+    u_int32_t increment;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_increment(self->db_env, &increment);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(increment);
+}
 
 static PyObject*
-DBEnv_set_mp_mmapsize(DBEnvObject* self, PyObject* args)
+DBEnv_mutex_set_tas_spins(DBEnvObject* self, PyObject* args)
 {
-    int err, mp_mmapsize;
+    int err;
+    int tas_spins;
 
-    if (!PyArg_ParseTuple(args, "i:set_mp_mmapsize", &mp_mmapsize))
+    if (!PyArg_ParseTuple(args, "i:mutex_set_tas_spins", &tas_spins))
         return NULL;
+
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_mp_mmapsize(self->db_env, mp_mmapsize);
+    err = self->db_env->mutex_set_tas_spins(self->db_env, tas_spins);
     MYDB_END_ALLOW_THREADS;
+
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_mutex_get_tas_spins(DBEnvObject* self)
+{
+    int err;
+    u_int32_t tas_spins;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_get_tas_spins(self->db_env, &tas_spins);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return NUMBER_FromLong(tas_spins);
+}
+#endif
 
 static PyObject*
-DBEnv_set_tmp_dir(DBEnvObject* self, PyObject* args)
+DBEnv_set_data_dir(DBEnvObject* self, PyObject* args)
 {
     int err;
     char *dir;
 
-    if (!PyArg_ParseTuple(args, "s:set_tmp_dir", &dir))
+    if (!PyArg_ParseTuple(args, "s:set_data_dir", &dir))
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_tmp_dir(self->db_env, dir);
+    err = self->db_env->set_data_dir(self->db_env, dir);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
 static PyObject*
-DBEnv_txn_recover(DBEnvObject* self)
+DBEnv_get_data_dirs(DBEnvObject* self)
 {
-    int flags = DB_FIRST;
-    int err, i;
-    PyObject *list, *tuple, *gid;
-    DBTxnObject *txn;
-#define PREPLIST_LEN 16
-    DB_PREPLIST preplist[PREPLIST_LEN];
-#if (DBVER < 48)
-    long retp;
-#else
-    u_int32_t retp;
-#endif
+    int err;
+    PyObject *tuple;
+    PyObject *item;
+    const char **dirpp;
+    int size, i;
 
     CHECK_ENV_NOT_CLOSED(self);
 
-    list=PyList_New(0);
-    if (!list)
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_data_dirs(self->db_env, &dirpp);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    /*
+    ** Calculate size. Python C API
+    ** actually allows for tuple resizing,
+    ** but this is simple enough.
+    */
+    for (size=0; *(dirpp+size) ; size++);
+
+    tuple = PyTuple_New(size);
+    if (!tuple)
         return NULL;
-    while (!0) {
-        MYDB_BEGIN_ALLOW_THREADS
-        err=self->db_env->txn_recover(self->db_env,
-                        preplist, PREPLIST_LEN, &retp, flags);
-#undef PREPLIST_LEN
+
+    for (i=0; i<size; i++) {
+        item = PyBytes_FromString (*(dirpp+i));
+        if (item == NULL) {
+            Py_DECREF(tuple);
+            tuple = NULL;
+            break;
+        }
+        PyTuple_SET_ITEM(tuple, i, item);
+    }
+    return tuple;
+}
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_set_lg_filemode(DBEnvObject* self, PyObject* args)
+{
+    int err, filemode;
+
+    if (!PyArg_ParseTuple(args, "i:set_lg_filemode", &filemode))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lg_filemode(self->db_env, filemode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lg_filemode(DBEnvObject* self)
+{
+    int err, filemode;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_filemode(self->db_env, &filemode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(filemode);
+}
+#endif
+
+static PyObject*
+DBEnv_set_lg_bsize(DBEnvObject* self, PyObject* args)
+{
+    int err, lg_bsize;
+
+    if (!PyArg_ParseTuple(args, "i:set_lg_bsize", &lg_bsize))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lg_bsize(self->db_env, lg_bsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lg_bsize(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lg_bsize;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_bsize(self->db_env, &lg_bsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lg_bsize);
+}
+
+static PyObject*
+DBEnv_set_lg_dir(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    char *dir;
+
+    if (!PyArg_ParseTuple(args, "s:set_lg_dir", &dir))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lg_dir(self->db_env, dir);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lg_dir(DBEnvObject* self)
+{
+    int err;
+    const char *dirp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_dir(self->db_env, &dirp);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyBytes_FromString(dirp);
+}
+
+static PyObject*
+DBEnv_set_lg_max(DBEnvObject* self, PyObject* args)
+{
+    int err, lg_max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lg_max", &lg_max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lg_max(self->db_env, lg_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lg_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lg_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_max(self->db_env, &lg_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lg_max);
+}
+
+static PyObject*
+DBEnv_set_lg_regionmax(DBEnvObject* self, PyObject* args)
+{
+    int err, lg_max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lg_regionmax", &lg_max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lg_regionmax(self->db_env, lg_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lg_regionmax(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lg_regionmax;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lg_regionmax(self->db_env, &lg_regionmax);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lg_regionmax);
+}
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_set_lk_partitions(DBEnvObject* self, PyObject* args)
+{
+    int err, lk_partitions;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_partitions", &lk_partitions))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_partitions(self->db_env, lk_partitions);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_partitions(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_partitions;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_partitions(self->db_env, &lk_partitions);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_partitions);
+}
+#endif
+
+static PyObject*
+DBEnv_set_lk_detect(DBEnvObject* self, PyObject* args)
+{
+    int err, lk_detect;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_detect", &lk_detect))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_detect(self->db_env, lk_detect);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_detect(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_detect;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_detect(self->db_env, &lk_detect);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_detect);
+}
+
+#if (DBVER < 45)
+static PyObject*
+DBEnv_set_lk_max(DBEnvObject* self, PyObject* args)
+{
+    int err, max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_max", &max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_max(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+
+static PyObject*
+DBEnv_set_lk_max_locks(DBEnvObject* self, PyObject* args)
+{
+    int err, max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_max_locks", &max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_max_locks(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_max_locks(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_locks(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
+
+static PyObject*
+DBEnv_set_lk_max_lockers(DBEnvObject* self, PyObject* args)
+{
+    int err, max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_max_lockers", &max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_max_lockers(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_max_lockers(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_lockers(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
+
+static PyObject*
+DBEnv_set_lk_max_objects(DBEnvObject* self, PyObject* args)
+{
+    int err, max;
+
+    if (!PyArg_ParseTuple(args, "i:set_lk_max_objects", &max))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_lk_max_objects(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_lk_max_objects(DBEnvObject* self)
+{
+    int err;
+    u_int32_t lk_max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_lk_max_objects(self->db_env, &lk_max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(lk_max);
+}
+
+static PyObject*
+DBEnv_get_mp_mmapsize(DBEnvObject* self)
+{
+    int err;
+    size_t mmapsize;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_mp_mmapsize(self->db_env, &mmapsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(mmapsize);
+}
+
+static PyObject*
+DBEnv_set_mp_mmapsize(DBEnvObject* self, PyObject* args)
+{
+    int err, mp_mmapsize;
+
+    if (!PyArg_ParseTuple(args, "i:set_mp_mmapsize", &mp_mmapsize))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_mp_mmapsize(self->db_env, mp_mmapsize);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBEnv_set_tmp_dir(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    char *dir;
+
+    if (!PyArg_ParseTuple(args, "s:set_tmp_dir", &dir))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_tmp_dir(self->db_env, dir);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_tmp_dir(DBEnvObject* self)
+{
+    int err;
+    const char *dirpp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tmp_dir(self->db_env, &dirpp);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+
+    return PyBytes_FromString(dirpp);
+}
+
+static PyObject*
+DBEnv_txn_recover(DBEnvObject* self)
+{
+    int flags = DB_FIRST;
+    int err, i;
+    PyObject *list, *tuple, *gid;
+    DBTxnObject *txn;
+#define PREPLIST_LEN 16
+    DB_PREPLIST preplist[PREPLIST_LEN];
+#if (DBVER < 48) || (DBVER >= 52)
+    long retp;
+#else
+    u_int32_t retp;
+#endif
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    list=PyList_New(0);
+    if (!list)
+        return NULL;
+    while (!0) {
+        MYDB_BEGIN_ALLOW_THREADS
+        err=self->db_env->txn_recover(self->db_env,
+                        preplist, PREPLIST_LEN, &retp, flags);
+#undef PREPLIST_LEN
         MYDB_END_ALLOW_THREADS
         if (err) {
             Py_DECREF(list);
@@ -4535,7 +6151,7 @@
                 Py_DECREF(list);
                 return NULL;
             }
-            txn=newDBTxnObject(self, NULL, preplist[i].txn, flags);
+            txn=newDBTxnObject(self, NULL, preplist[i].txn, 0);
             if (!txn) {
                 Py_DECREF(list);
                 Py_DECREF(gid);
@@ -4609,6 +6225,20 @@
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_tx_max(DBEnvObject* self)
+{
+    int err;
+    u_int32_t max;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tx_max(self->db_env, &max);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return PyLong_FromUnsignedLong(max);
+}
 
 static PyObject*
 DBEnv_set_tx_max(DBEnvObject* self, PyObject* args)
@@ -4619,11 +6249,27 @@
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
+    MYDB_BEGIN_ALLOW_THREADS;
     err = self->db_env->set_tx_max(self->db_env, max);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
 
+static PyObject*
+DBEnv_get_tx_timestamp(DBEnvObject* self)
+{
+    int err;
+    time_t timestamp;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_tx_timestamp(self->db_env, &timestamp);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(timestamp);
+}
 
 static PyObject*
 DBEnv_set_tx_timestamp(DBEnvObject* self, PyObject* args)
@@ -4636,7 +6282,9 @@
         return NULL;
     CHECK_ENV_NOT_CLOSED(self);
     timestamp = (time_t)stamp;
+    MYDB_BEGIN_ALLOW_THREADS;
     err = self->db_env->set_tx_timestamp(self->db_env, &timestamp);
+    MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
 }
@@ -4730,6 +6378,26 @@
 
 #if (DBVER >= 44)
 static PyObject*
+DBEnv_fileid_reset(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    char *file;
+    u_int32_t flags = 0;
+    static char* kwnames[] = { "file", "flags", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "z|i:fileid_reset", kwnames,
+                                     &file, &flags))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->fileid_reset(self->db_env, file, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
 DBEnv_lsn_reset(DBEnvObject* self, PyObject* args, PyObject* kwargs)
 {
     int err;
@@ -4750,6 +6418,28 @@
 }
 #endif /* DBVER >= 4.4 */
 
+
+static PyObject*
+DBEnv_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
 static PyObject*
 DBEnv_log_stat(DBEnvObject* self, PyObject* args)
 {
@@ -4785,9 +6475,6 @@
     MAKE_ENTRY(lg_size);
     MAKE_ENTRY(record);
 #endif
-#if (DBVER < 41)
-    MAKE_ENTRY(lg_max);
-#endif
     MAKE_ENTRY(w_mbytes);
     MAKE_ENTRY(w_bytes);
     MAKE_ENTRY(wc_mbytes);
@@ -4815,6 +6502,27 @@
 
 
 static PyObject*
+DBEnv_log_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:log_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
 DBEnv_lock_stat(DBEnvObject* self, PyObject* args)
 {
     int err;
@@ -4840,13 +6548,8 @@
 
 #define MAKE_ENTRY(name)  _addIntToDict(d, #name, sp->st_##name)
 
-#if (DBVER < 41)
-    MAKE_ENTRY(lastid);
-#endif
-#if (DBVER >=41)
     MAKE_ENTRY(id);
     MAKE_ENTRY(cur_maxid);
-#endif
     MAKE_ENTRY(nmodes);
     MAKE_ENTRY(maxlocks);
     MAKE_ENTRY(maxlockers);
@@ -4871,10 +6574,8 @@
     MAKE_ENTRY(lock_wait);
 #endif
     MAKE_ENTRY(ndeadlocks);
-#if (DBVER >= 41)
     MAKE_ENTRY(locktimeout);
     MAKE_ENTRY(txntimeout);
-#endif
     MAKE_ENTRY(nlocktimeouts);
     MAKE_ENTRY(ntxntimeouts);
 #if (DBVER >= 46)
@@ -4901,6 +6602,43 @@
 }
 
 static PyObject*
+DBEnv_lock_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:lock_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->lock_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+static PyObject*
+DBEnv_log_cursor(DBEnvObject* self)
+{
+    int err;
+    DB_LOGC* dblogc;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_cursor(self->db_env, &dblogc, 0);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return (PyObject*) newDBLogCursorObject(dblogc, self);
+}
+
+
+static PyObject*
 DBEnv_log_flush(DBEnvObject* self)
 {
     int err;
@@ -4916,6 +6654,86 @@
 }
 
 static PyObject*
+DBEnv_log_file(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_LSN lsn = {0, 0};
+    int size = 20;
+    char *name = NULL;
+    PyObject *retval;
+
+    if (!PyArg_ParseTuple(args, "(ii):log_file", &lsn.file, &lsn.offset))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    do {
+        name = malloc(size);
+        if (!name) {
+            PyErr_NoMemory();
+            return NULL;
+        }
+        MYDB_BEGIN_ALLOW_THREADS;
+        err = self->db_env->log_file(self->db_env, &lsn, name, size);
+        MYDB_END_ALLOW_THREADS;
+        if (err == EINVAL) {
+            free(name);
+            size *= 2;
+        } else if (err) {
+            free(name);
+            RETURN_IF_ERR();
+            assert(0);  /* Unreachable... supposely */
+            return NULL;
+        }
+/*
+** If the final buffer we try is too small, we will
+** get this exception:
+** DBInvalidArgError:
+**    (22, 'Invalid argument -- DB_ENV->log_file: name buffer is too short')
+*/
+    } while ((err == EINVAL) && (size<(1<<17)));
+
+    RETURN_IF_ERR();  /* Maybe the size is not the problem */
+
+    retval = Py_BuildValue("s", name);
+    free(name);
+    return retval;
+}
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_log_printf(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    char *string;
+    PyObject *txnobj = NULL;
+    DB_TXN *txn = NULL;
+    static char* kwnames[] = {"string", "txn", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|O:log_printf", kwnames,
+                &string, &txnobj))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    if (!checkTxnObj(txnobj, &txn))
+        return NULL;
+
+    /*
+    ** Do not use the format string directly, to avoid attacks.
+    */
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->log_printf(self->db_env, txn, "%s", string);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
 DBEnv_log_archive(DBEnvObject* self, PyObject* args)
 {
     int flags=0;
@@ -4963,6 +6781,143 @@
 }
 
 
+#if (DBVER >= 52)
+static PyObject*
+DBEnv_repmgr_site(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    DB_SITE* site;
+    char *host;
+    u_int port;
+    static char* kwnames[] = {"host", "port", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "si:repmgr_site", kwnames,
+                                     &host, &port))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->repmgr_site(self->db_env, host, port, &site, 0);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return (PyObject*) newDBSiteObject(site, self);
+}
+
+static PyObject*
+DBEnv_repmgr_site_by_eid(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    DB_SITE* site;
+    int eid;
+    static char* kwnames[] = {"eid", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:repmgr_site_by_eid",
+                kwnames, &eid))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->repmgr_site_by_eid(self->db_env, eid, &site);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return (PyObject*) newDBSiteObject(site, self);
+}
+#endif
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_mutex_stat(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    DB_MUTEX_STAT* statp = NULL;
+    PyObject* d = NULL;
+    u_int32_t flags = 0;
+
+    if (!PyArg_ParseTuple(args, "|i:mutex_stat", &flags))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_stat(self->db_env, &statp, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    /* Turn the stat structure into a dictionary */
+    d = PyDict_New();
+    if (d == NULL) {
+        if (statp)
+            free(statp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(d, #name, statp->st_##name)
+
+    MAKE_ENTRY(mutex_align);
+    MAKE_ENTRY(mutex_tas_spins);
+    MAKE_ENTRY(mutex_cnt);
+    MAKE_ENTRY(mutex_free);
+    MAKE_ENTRY(mutex_inuse);
+    MAKE_ENTRY(mutex_inuse_max);
+    MAKE_ENTRY(regsize);
+    MAKE_ENTRY(region_wait);
+    MAKE_ENTRY(region_nowait);
+
+#undef MAKE_ENTRY
+    free(statp);
+    return d;
+}
+#endif
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBEnv_mutex_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:mutex_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->mutex_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+static PyObject*
+DBEnv_txn_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->txn_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
 static PyObject*
 DBEnv_txn_stat(DBEnvObject* self, PyObject* args)
 {
@@ -5037,47 +6992,192 @@
 }
 
 static PyObject*
-DBEnv_get_private(DBEnvObject* self)
+DBEnv_get_private(DBEnvObject* self)
+{
+    /* We can give out the private field even if dbenv is closed */
+    Py_INCREF(self->private_obj);
+    return self->private_obj;
+}
+
+static PyObject*
+DBEnv_set_private(DBEnvObject* self, PyObject* private_obj)
+{
+    /* We can set the private field even if dbenv is closed */
+    Py_DECREF(self->private_obj);
+    Py_INCREF(private_obj);
+    self->private_obj = private_obj;
+    RETURN_NONE();
+}
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_set_intermediate_dir_mode(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    const char *mode;
+
+    if (!PyArg_ParseTuple(args,"s:set_intermediate_dir_mode", &mode))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_intermediate_dir_mode(self->db_env, mode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_intermediate_dir_mode(DBEnvObject* self)
+{
+    int err;
+    const char *mode;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_intermediate_dir_mode(self->db_env, &mode);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return Py_BuildValue("s", mode);
+}
+#endif
+
+#if (DBVER < 47)
+static PyObject*
+DBEnv_set_intermediate_dir(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int mode;
+    u_int32_t flags;
+
+    if (!PyArg_ParseTuple(args, "iI:set_intermediate_dir", &mode, &flags))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_intermediate_dir(self->db_env, mode, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+static PyObject*
+DBEnv_get_open_flags(DBEnvObject* self)
+{
+    int err;
+    unsigned int flags;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_open_flags(self->db_env, &flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(flags);
+}
+
+#if (DBVER < 48)
+static PyObject*
+DBEnv_set_rpc_server(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    char *host;
+    long cl_timeout=0, sv_timeout=0;
+
+    static char* kwnames[] = { "host", "cl_timeout", "sv_timeout", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|ll:set_rpc_server", kwnames,
+                                     &host, &cl_timeout, &sv_timeout))
+        return NULL;
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_rpc_server(self->db_env, NULL, host, cl_timeout,
+            sv_timeout, 0);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+static PyObject*
+DBEnv_set_mp_max_openfd(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    int maxopenfd;
+
+    if (!PyArg_ParseTuple(args, "i:set_mp_max_openfd", &maxopenfd)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_mp_max_openfd(self->db_env, maxopenfd);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_get_mp_max_openfd(DBEnvObject* self)
 {
-    /* We can give out the private field even if dbenv is closed */
-    Py_INCREF(self->private_obj);
-    return self->private_obj;
+    int err;
+    int maxopenfd;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->get_mp_max_openfd(self->db_env, &maxopenfd);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return NUMBER_FromLong(maxopenfd);
 }
 
+
 static PyObject*
-DBEnv_set_private(DBEnvObject* self, PyObject* private_obj)
+DBEnv_set_mp_max_write(DBEnvObject* self, PyObject* args)
 {
-    /* We can set the private field even if dbenv is closed */
-    Py_DECREF(self->private_obj);
-    Py_INCREF(private_obj);
-    self->private_obj = private_obj;
+    int err;
+    int maxwrite, maxwrite_sleep;
+
+    if (!PyArg_ParseTuple(args, "ii:set_mp_max_write", &maxwrite,
+                &maxwrite_sleep)) {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->set_mp_max_write(self->db_env, maxwrite,
+            maxwrite_sleep);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
     RETURN_NONE();
 }
 
-
-#if (DBVER < 48)
 static PyObject*
-DBEnv_set_rpc_server(DBEnvObject* self, PyObject* args, PyObject* kwargs)
+DBEnv_get_mp_max_write(DBEnvObject* self)
 {
     int err;
-    char *host;
-    long cl_timeout=0, sv_timeout=0;
-
-    static char* kwnames[] = { "host", "cl_timeout", "sv_timeout", NULL};
+    int maxwrite;
+#if (DBVER >= 46)
+    db_timeout_t maxwrite_sleep;
+#else
+    int maxwrite_sleep;
+#endif
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|ll:set_rpc_server", kwnames,
-                                     &host, &cl_timeout, &sv_timeout))
-        return NULL;
     CHECK_ENV_NOT_CLOSED(self);
 
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->set_rpc_server(self->db_env, NULL, host, cl_timeout,
-            sv_timeout, 0);
+    err = self->db_env->get_mp_max_write(self->db_env, &maxwrite,
+            &maxwrite_sleep);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-    RETURN_NONE();
+
+    return Py_BuildValue("(ii)", maxwrite, (int)maxwrite_sleep);
 }
-#endif
+
 
 static PyObject*
 DBEnv_set_verbose(DBEnvObject* self, PyObject* args)
@@ -5096,7 +7196,6 @@
     RETURN_NONE();
 }
 
-#if (DBVER >= 42)
 static PyObject*
 DBEnv_get_verbose(DBEnvObject* self, PyObject* args)
 {
@@ -5114,7 +7213,6 @@
     RETURN_IF_ERR();
     return PyBool_FromLong(verbose);
 }
-#endif
 
 #if (DBVER >= 45)
 static void
@@ -5196,9 +7294,7 @@
     PyObject *control_py, *rec_py;
     DBT control, rec;
     int envid;
-#if (DBVER >= 42)
     DB_LSN lsn;
-#endif
 
     if (!PyArg_ParseTuple(args, "OOi:rep_process_message", &control_py,
                 &rec_py, &envid))
@@ -5215,13 +7311,8 @@
     err = self->db_env->rep_process_message(self->db_env, &control, &rec,
             envid, &lsn);
 #else
-#if (DBVER >= 42)
     err = self->db_env->rep_process_message(self->db_env, &control, &rec,
             &envid, &lsn);
-#else
-    err = self->db_env->rep_process_message(self->db_env, &control, &rec,
-            &envid);
-#endif
 #endif
     MYDB_END_ALLOW_THREADS;
     switch (err) {
@@ -5250,15 +7341,13 @@
                 return r;
                 break;
             }
-#if (DBVER >= 42)
         case DB_REP_NOTPERM :
         case DB_REP_ISPERM :
             return Py_BuildValue("(i(ll))", err, lsn.file, lsn.offset);
             break;
-#endif
     }
     RETURN_IF_ERR();
-    return Py_BuildValue("(OO)", Py_None, Py_None);
+    return PyTuple_Pack(2, Py_None, Py_None);
 }
 
 static int
@@ -5283,11 +7372,7 @@
     b = PyBytes_FromStringAndSize(rec->data, rec->size);
 
     args = Py_BuildValue(
-#if (PY_VERSION_HEX >= 0x02040000)
             "(OOO(ll)iI)",
-#else
-            "(OOO(ll)ii)",
-#endif
             dbenv,
             a, b,
             lsn->file, lsn->offset, envid, flags);
@@ -5307,20 +7392,6 @@
     return ret;
 }
 
-#if (DBVER <= 41)
-static int
-_DBEnv_rep_transportCallbackOLD(DB_ENV* db_env, const DBT* control, const DBT* rec,
-        int envid, u_int32_t flags)
-{
-    DB_LSN lsn;
-
-    lsn.file = -1;  /* Dummy values */
-    lsn.offset = -1;
-    return _DBEnv_rep_transportCallback(db_env, control, rec, &lsn, envid,
-            flags);
-}
-#endif
-
 static PyObject*
 DBEnv_rep_set_transport(DBEnvObject* self, PyObject* args)
 {
@@ -5341,13 +7412,8 @@
     err = self->db_env->rep_set_transport(self->db_env, envid,
             &_DBEnv_rep_transportCallback);
 #else
-#if (DBVER >= 42)
     err = self->db_env->set_rep_transport(self->db_env, envid,
             &_DBEnv_rep_transportCallback);
-#else
-    err = self->db_env->set_rep_transport(self->db_env, envid,
-            &_DBEnv_rep_transportCallbackOLD);
-#endif
 #endif
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
@@ -5387,11 +7453,7 @@
     err = self->db_env->rep_get_request(self->db_env, &minimum, &maximum);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
-#if (PY_VERSION_HEX >= 0x02040000)
     return Py_BuildValue("II", minimum, maximum);
-#else
-    return Py_BuildValue("ii", minimum, maximum);
-#endif
 }
 #endif
 
@@ -5478,7 +7540,7 @@
     }
     CHECK_ENV_NOT_CLOSED(self);
     MYDB_BEGIN_ALLOW_THREADS;
-    err = self->db_env->rep_elect(self->db_env, nvotes, nvotes, 0);
+    err = self->db_env->rep_elect(self->db_env, nsites, nvotes, 0);
     MYDB_END_ALLOW_THREADS;
     RETURN_IF_ERR();
     RETURN_NONE();
@@ -5635,6 +7697,162 @@
 }
 #endif
 
+
+#if (DBVER >= 47)
+static PyObject*
+DBEnv_rep_set_clockskew(DBEnvObject* self, PyObject* args)
+{
+    int err;
+    unsigned int fast, slow;
+
+    if (!PyArg_ParseTuple(args,"II:rep_set_clockskew", &fast, &slow))
+        return NULL;
+
+    CHECK_ENV_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_set_clockskew(self->db_env, fast, slow);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_rep_get_clockskew(DBEnvObject* self)
+{
+    int err;
+    unsigned int fast, slow;
+
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_get_clockskew(self->db_env, &fast, &slow);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    return Py_BuildValue("(II)", fast, slow);
+}
+#endif
+
+static PyObject*
+DBEnv_rep_stat_print(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:rep_stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_stat_print(self->db_env, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+static PyObject*
+DBEnv_rep_stat(DBEnvObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    DB_REP_STAT *statp;
+    PyObject *stats;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:rep_stat",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+    CHECK_ENV_NOT_CLOSED(self);
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->db_env->rep_stat(self->db_env, &statp, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+
+    stats=PyDict_New();
+    if (stats == NULL) {
+        free(statp);
+        return NULL;
+    }
+
+#define MAKE_ENTRY(name)  _addIntToDict(stats, #name, statp->st_##name)
+#define MAKE_DB_LSN_ENTRY(name) _addDB_lsnToDict(stats , #name, statp->st_##name)
+
+#if (DBVER >= 44)
+    MAKE_ENTRY(bulk_fills);
+    MAKE_ENTRY(bulk_overflows);
+    MAKE_ENTRY(bulk_records);
+    MAKE_ENTRY(bulk_transfers);
+    MAKE_ENTRY(client_rerequests);
+    MAKE_ENTRY(client_svc_miss);
+    MAKE_ENTRY(client_svc_req);
+#endif
+    MAKE_ENTRY(dupmasters);
+    MAKE_ENTRY(egen);
+    MAKE_ENTRY(election_nvotes);
+    MAKE_ENTRY(startup_complete);
+    MAKE_ENTRY(pg_duplicated);
+    MAKE_ENTRY(pg_records);
+    MAKE_ENTRY(pg_requested);
+    MAKE_ENTRY(next_pg);
+    MAKE_ENTRY(waiting_pg);
+    MAKE_ENTRY(election_cur_winner);
+    MAKE_ENTRY(election_gen);
+    MAKE_DB_LSN_ENTRY(election_lsn);
+    MAKE_ENTRY(election_nsites);
+    MAKE_ENTRY(election_priority);
+#if (DBVER >= 44)
+    MAKE_ENTRY(election_sec);
+    MAKE_ENTRY(election_usec);
+#endif
+    MAKE_ENTRY(election_status);
+    MAKE_ENTRY(election_tiebreaker);
+    MAKE_ENTRY(election_votes);
+    MAKE_ENTRY(elections);
+    MAKE_ENTRY(elections_won);
+    MAKE_ENTRY(env_id);
+    MAKE_ENTRY(env_priority);
+    MAKE_ENTRY(gen);
+    MAKE_ENTRY(log_duplicated);
+    MAKE_ENTRY(log_queued);
+    MAKE_ENTRY(log_queued_max);
+    MAKE_ENTRY(log_queued_total);
+    MAKE_ENTRY(log_records);
+    MAKE_ENTRY(log_requested);
+    MAKE_ENTRY(master);
+    MAKE_ENTRY(master_changes);
+#if (DBVER >= 47)
+    MAKE_ENTRY(max_lease_sec);
+    MAKE_ENTRY(max_lease_usec);
+    MAKE_DB_LSN_ENTRY(max_perm_lsn);
+#endif
+    MAKE_ENTRY(msgs_badgen);
+    MAKE_ENTRY(msgs_processed);
+    MAKE_ENTRY(msgs_recover);
+    MAKE_ENTRY(msgs_send_failures);
+    MAKE_ENTRY(msgs_sent);
+    MAKE_ENTRY(newsites);
+    MAKE_DB_LSN_ENTRY(next_lsn);
+    MAKE_ENTRY(nsites);
+    MAKE_ENTRY(nthrottles);
+    MAKE_ENTRY(outdated);
+#if (DBVER >= 46)
+    MAKE_ENTRY(startsync_delayed);
+#endif
+    MAKE_ENTRY(status);
+    MAKE_ENTRY(txns_applied);
+    MAKE_DB_LSN_ENTRY(waiting_lsn);
+
+#undef MAKE_DB_LSN_ENTRY
+#undef MAKE_ENTRY
+
+    free(statp);
+    return stats;
+}
+
 /* --------------------------------------------------------------------- */
 /* REPLICATION METHODS: Replication Manager */
 
@@ -5660,6 +7878,7 @@
     RETURN_NONE();
 }
 
+#if (DBVER < 52)
 static PyObject*
 DBEnv_repmgr_set_local_site(DBEnvObject* self, PyObject* args, PyObject*
         kwargs)
@@ -5706,6 +7925,7 @@
     RETURN_IF_ERR();
     return NUMBER_FromLong(eidp);
 }
+#endif
 
 static PyObject*
 DBEnv_repmgr_set_ack_policy(DBEnvObject* self, PyObject* args)
@@ -5766,13 +7986,8 @@
             free(listp);
             return NULL;
         }
-#if (PY_VERSION_HEX >= 0x02040000)
         tuple=Py_BuildValue("(sII)", listp[countp].host,
                 listp[countp].port, listp[countp].status);
-#else
-        tuple=Py_BuildValue("(sii)", listp[countp].host,
-                listp[countp].port, listp[countp].status);
-#endif
         if(!tuple) {
             Py_DECREF(key);
             Py_DECREF(stats);
@@ -5876,9 +8091,7 @@
 static void _promote_transaction_dbs_and_sequences(DBTxnObject *txn)
 {
     DBObject *db;
-#if (DBVER >= 43)
     DBSequenceObject *dbs;
-#endif
 
     while (txn->children_dbs) {
         db=txn->children_dbs;
@@ -5894,7 +8107,6 @@
         }
     }
 
-#if (DBVER >= 43)
     while (txn->children_sequences) {
         dbs=txn->children_sequences;
         EXTRACT_FROM_DOUBLE_LINKED_LIST_TXN(dbs);
@@ -5908,7 +8120,6 @@
             dbs->txn=NULL;
         }
     }
-#endif
 }
 
 
@@ -6005,12 +8216,10 @@
     self->txn = NULL;   /* this DB_TXN is no longer valid after this call */
 
     _close_transaction_cursors(self);
-#if (DBVER >= 43)
     while (self->children_sequences) {
         dummy=DBSequence_close_internal(self->children_sequences,0,0);
         Py_XDECREF(dummy);
     }
-#endif
     while (self->children_dbs) {
         dummy=DB_close_internal(self->children_dbs, 0, 0);
         Py_XDECREF(dummy);
@@ -6076,7 +8285,76 @@
     return NUMBER_FromLong(id);
 }
 
-#if (DBVER >= 43)
+
+static PyObject*
+DBTxn_set_timeout(DBTxnObject* self, PyObject* args, PyObject* kwargs)
+{
+    int err;
+    u_int32_t flags=0;
+    u_int32_t timeout = 0;
+    static char* kwnames[] = { "timeout", "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:set_timeout", kwnames,
+                &timeout, &flags)) {
+        return NULL;
+    }
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->set_timeout(self->txn, (db_timeout_t)timeout, flags);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBTxn_set_name(DBTxnObject* self, PyObject* args)
+{
+    int err;
+    const char *name;
+
+    if (!PyArg_ParseTuple(args, "s:set_name", &name))
+        return NULL;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->set_name(self->txn, name);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+#endif
+
+
+#if (DBVER >= 44)
+static PyObject*
+DBTxn_get_name(DBTxnObject* self)
+{
+    int err;
+    const char *name;
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->txn->get_name(self->txn, &name);
+    MYDB_END_ALLOW_THREADS;
+
+    RETURN_IF_ERR();
+#if (PY_VERSION_HEX < 0x03000000)
+    if (!name) {
+        return PyString_FromString("");
+    }
+    return PyString_FromString(name);
+#else
+    if (!name) {
+        return PyUnicode_FromString("");
+    }
+    return PyUnicode_FromString(name);
+#endif
+}
+#endif
+
+
 /* --------------------------------------------------------------------- */
 /* DBSequence methods */
 
@@ -6179,12 +8457,12 @@
 }
 
 static PyObject*
-DBSequence_init_value(DBSequenceObject* self, PyObject* args)
+DBSequence_initial_value(DBSequenceObject* self, PyObject* args)
 {
     int err;
     PY_LONG_LONG value;
     db_seq_t value2;
-    if (!PyArg_ParseTuple(args,"L:init_value", &value))
+    if (!PyArg_ParseTuple(args,"L:initial_value", &value))
         return NULL;
     CHECK_SEQUENCE_NOT_CLOSED(self)
 
@@ -6362,6 +8640,29 @@
     return Py_BuildValue("(LL)", min, max);
 }
 
+
+static PyObject*
+DBSequence_stat_print(DBSequenceObject* self, PyObject* args, PyObject *kwargs)
+{
+    int err;
+    int flags=0;
+    static char* kwnames[] = { "flags", NULL };
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:stat_print",
+                kwnames, &flags))
+    {
+        return NULL;
+    }
+
+    CHECK_SEQUENCE_NOT_CLOSED(self);
+
+    MYDB_BEGIN_ALLOW_THREADS;
+    err = self->sequence->stat_print(self->sequence, flags);
+    MYDB_END_ALLOW_THREADS;
+    RETURN_IF_ERR();
+    RETURN_NONE();
+}
+
 static PyObject*
 DBSequence_stat(DBSequenceObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -6403,7 +8704,6 @@
     free(sp);
     return dict_stat;
 }
-#endif
 
 
 /* --------------------------------------------------------------------- */
@@ -6413,11 +8713,18 @@
     {"append",          (PyCFunction)DB_append,         METH_VARARGS|METH_KEYWORDS},
     {"associate",       (PyCFunction)DB_associate,      METH_VARARGS|METH_KEYWORDS},
     {"close",           (PyCFunction)DB_close,          METH_VARARGS},
+#if (DBVER >= 47)
+    {"compact",         (PyCFunction)DB_compact,        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"consume",         (PyCFunction)DB_consume,        METH_VARARGS|METH_KEYWORDS},
     {"consume_wait",    (PyCFunction)DB_consume_wait,   METH_VARARGS|METH_KEYWORDS},
     {"cursor",          (PyCFunction)DB_cursor,         METH_VARARGS|METH_KEYWORDS},
     {"delete",          (PyCFunction)DB_delete,         METH_VARARGS|METH_KEYWORDS},
     {"fd",              (PyCFunction)DB_fd,             METH_NOARGS},
+#if (DBVER >= 46)
+    {"exists",          (PyCFunction)DB_exists,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"get",             (PyCFunction)DB_get,            METH_VARARGS|METH_KEYWORDS},
     {"pget",            (PyCFunction)DB_pget,           METH_VARARGS|METH_KEYWORDS},
     {"get_both",        (PyCFunction)DB_get_both,       METH_VARARGS|METH_KEYWORDS},
@@ -6434,24 +8741,45 @@
     {"remove",          (PyCFunction)DB_remove,         METH_VARARGS|METH_KEYWORDS},
     {"rename",          (PyCFunction)DB_rename,         METH_VARARGS},
     {"set_bt_minkey",   (PyCFunction)DB_set_bt_minkey,  METH_VARARGS},
+    {"get_bt_minkey",   (PyCFunction)DB_get_bt_minkey,  METH_NOARGS},
     {"set_bt_compare",  (PyCFunction)DB_set_bt_compare, METH_O},
     {"set_cachesize",   (PyCFunction)DB_set_cachesize,  METH_VARARGS},
-#if (DBVER >= 41)
+    {"get_cachesize",   (PyCFunction)DB_get_cachesize,  METH_NOARGS},
+    {"set_dup_compare", (PyCFunction)DB_set_dup_compare, METH_O},
     {"set_encrypt",     (PyCFunction)DB_set_encrypt,    METH_VARARGS|METH_KEYWORDS},
-#endif
+    {"get_encrypt_flags", (PyCFunction)DB_get_encrypt_flags, METH_NOARGS},
     {"set_flags",       (PyCFunction)DB_set_flags,      METH_VARARGS},
+    {"get_flags",       (PyCFunction)DB_get_flags,      METH_NOARGS},
+    {"get_transactional", (PyCFunction)DB_get_transactional, METH_NOARGS},
     {"set_h_ffactor",   (PyCFunction)DB_set_h_ffactor,  METH_VARARGS},
+    {"get_h_ffactor",   (PyCFunction)DB_get_h_ffactor,  METH_NOARGS},
     {"set_h_nelem",     (PyCFunction)DB_set_h_nelem,    METH_VARARGS},
+    {"get_h_nelem",     (PyCFunction)DB_get_h_nelem,    METH_NOARGS},
     {"set_lorder",      (PyCFunction)DB_set_lorder,     METH_VARARGS},
+    {"get_lorder",      (PyCFunction)DB_get_lorder,     METH_NOARGS},
     {"set_pagesize",    (PyCFunction)DB_set_pagesize,   METH_VARARGS},
+    {"get_pagesize",    (PyCFunction)DB_get_pagesize,   METH_NOARGS},
     {"set_re_delim",    (PyCFunction)DB_set_re_delim,   METH_VARARGS},
+    {"get_re_delim",    (PyCFunction)DB_get_re_delim,   METH_NOARGS},
     {"set_re_len",      (PyCFunction)DB_set_re_len,     METH_VARARGS},
+    {"get_re_len",      (PyCFunction)DB_get_re_len,     METH_NOARGS},
     {"set_re_pad",      (PyCFunction)DB_set_re_pad,     METH_VARARGS},
+    {"get_re_pad",      (PyCFunction)DB_get_re_pad,     METH_NOARGS},
     {"set_re_source",   (PyCFunction)DB_set_re_source,  METH_VARARGS},
+    {"get_re_source",   (PyCFunction)DB_get_re_source,  METH_NOARGS},
     {"set_q_extentsize",(PyCFunction)DB_set_q_extentsize, METH_VARARGS},
+    {"get_q_extentsize",(PyCFunction)DB_get_q_extentsize, METH_NOARGS},
     {"set_private",     (PyCFunction)DB_set_private,    METH_O},
     {"get_private",     (PyCFunction)DB_get_private,    METH_NOARGS},
+#if (DBVER >= 46)
+    {"set_priority",    (PyCFunction)DB_set_priority,   METH_VARARGS},
+    {"get_priority",    (PyCFunction)DB_get_priority,   METH_NOARGS},
+#endif
+    {"get_dbname",      (PyCFunction)DB_get_dbname,     METH_NOARGS},
+    {"get_open_flags",  (PyCFunction)DB_get_open_flags, METH_NOARGS},
     {"stat",            (PyCFunction)DB_stat,           METH_VARARGS|METH_KEYWORDS},
+    {"stat_print",      (PyCFunction)DB_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
     {"sync",            (PyCFunction)DB_sync,           METH_VARARGS},
     {"truncate",        (PyCFunction)DB_truncate,       METH_VARARGS|METH_KEYWORDS},
     {"type",            (PyCFunction)DB_get_type,       METH_NOARGS},
@@ -6463,6 +8791,20 @@
 };
 
 
+/* We need this to support __contains__() */
+static PySequenceMethods DB_sequence = {
+    0, /* sq_length, mapping wins here */
+    0, /* sq_concat */
+    0, /* sq_repeat */
+    0, /* sq_item */
+    0, /* sq_slice */
+    0, /* sq_ass_item */
+    0, /* sq_ass_slice */
+    (objobjproc)DB_contains, /* sq_contains */
+    0, /* sq_inplace_concat */
+    0, /* sq_inplace_repeat */
+};
+
 static PyMappingMethods DB_mapping = {
         DB_length,                   /*mp_length*/
         (binaryfunc)DB_subscript,    /*mp_subscript*/
@@ -6493,74 +8835,192 @@
     {"consume",         (PyCFunction)DBC_consume,       METH_VARARGS|METH_KEYWORDS},
     {"next_dup",        (PyCFunction)DBC_next_dup,      METH_VARARGS|METH_KEYWORDS},
     {"next_nodup",      (PyCFunction)DBC_next_nodup,    METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 46)
+    {"prev_dup",        (PyCFunction)DBC_prev_dup,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
     {"prev_nodup",      (PyCFunction)DBC_prev_nodup,    METH_VARARGS|METH_KEYWORDS},
     {"join_item",       (PyCFunction)DBC_join_item,     METH_VARARGS},
+#if (DBVER >= 46)
+    {"set_priority",    (PyCFunction)DBC_set_priority,
+        METH_VARARGS|METH_KEYWORDS},
+    {"get_priority",    (PyCFunction)DBC_get_priority, METH_NOARGS},
+#endif
+    {NULL,      NULL}       /* sentinel */
+};
+
+
+static PyMethodDef DBLogCursor_methods[] = {
+    {"close",   (PyCFunction)DBLogCursor_close,     METH_NOARGS},
+    {"current", (PyCFunction)DBLogCursor_current,   METH_NOARGS},
+    {"first",   (PyCFunction)DBLogCursor_first,     METH_NOARGS},
+    {"last",    (PyCFunction)DBLogCursor_last,      METH_NOARGS},
+    {"next",    (PyCFunction)DBLogCursor_next,      METH_NOARGS},
+    {"prev",    (PyCFunction)DBLogCursor_prev,      METH_NOARGS},
+    {"set",     (PyCFunction)DBLogCursor_set,       METH_VARARGS},
     {NULL,      NULL}       /* sentinel */
 };
 
+#if (DBVER >= 52)
+static PyMethodDef DBSite_methods[] = {
+    {"get_config",  (PyCFunction)DBSite_get_config,
+        METH_VARARGS | METH_KEYWORDS},
+    {"set_config",  (PyCFunction)DBSite_set_config,
+        METH_VARARGS | METH_KEYWORDS},
+    {"remove",      (PyCFunction)DBSite_remove,     METH_NOARGS},
+    {"get_eid",     (PyCFunction)DBSite_get_eid,    METH_NOARGS},
+    {"get_address", (PyCFunction)DBSite_get_address,    METH_NOARGS},
+    {"close",       (PyCFunction)DBSite_close,      METH_NOARGS},
+    {NULL,      NULL}       /* sentinel */
+};
+#endif
 
 static PyMethodDef DBEnv_methods[] = {
     {"close",           (PyCFunction)DBEnv_close,            METH_VARARGS},
     {"open",            (PyCFunction)DBEnv_open,             METH_VARARGS},
     {"remove",          (PyCFunction)DBEnv_remove,           METH_VARARGS},
-#if (DBVER >= 41)
     {"dbremove",        (PyCFunction)DBEnv_dbremove,         METH_VARARGS|METH_KEYWORDS},
     {"dbrename",        (PyCFunction)DBEnv_dbrename,         METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 46)
+    {"set_thread_count", (PyCFunction)DBEnv_set_thread_count, METH_VARARGS},
+    {"get_thread_count", (PyCFunction)DBEnv_get_thread_count, METH_NOARGS},
+#endif
     {"set_encrypt",     (PyCFunction)DBEnv_set_encrypt,      METH_VARARGS|METH_KEYWORDS},
+    {"get_encrypt_flags", (PyCFunction)DBEnv_get_encrypt_flags, METH_NOARGS},
+    {"get_timeout",     (PyCFunction)DBEnv_get_timeout,
+        METH_VARARGS|METH_KEYWORDS},
+    {"set_timeout",     (PyCFunction)DBEnv_set_timeout,     METH_VARARGS|METH_KEYWORDS},
+    {"set_shm_key",     (PyCFunction)DBEnv_set_shm_key,     METH_VARARGS},
+    {"get_shm_key",     (PyCFunction)DBEnv_get_shm_key,     METH_NOARGS},
+#if (DBVER >= 46)
+    {"set_cache_max",   (PyCFunction)DBEnv_set_cache_max,   METH_VARARGS},
+    {"get_cache_max",   (PyCFunction)DBEnv_get_cache_max,   METH_NOARGS},
+#endif
+    {"set_cachesize",   (PyCFunction)DBEnv_set_cachesize,   METH_VARARGS},
+    {"get_cachesize",   (PyCFunction)DBEnv_get_cachesize,   METH_NOARGS},
+    {"memp_trickle",    (PyCFunction)DBEnv_memp_trickle,    METH_VARARGS},
+    {"memp_sync",       (PyCFunction)DBEnv_memp_sync,       METH_VARARGS},
+    {"memp_stat",       (PyCFunction)DBEnv_memp_stat,
+        METH_VARARGS|METH_KEYWORDS},
+    {"memp_stat_print", (PyCFunction)DBEnv_memp_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 44)
+    {"mutex_set_max",   (PyCFunction)DBEnv_mutex_set_max,   METH_VARARGS},
+    {"mutex_get_max",   (PyCFunction)DBEnv_mutex_get_max,   METH_NOARGS},
+    {"mutex_set_align", (PyCFunction)DBEnv_mutex_set_align, METH_VARARGS},
+    {"mutex_get_align", (PyCFunction)DBEnv_mutex_get_align, METH_NOARGS},
+    {"mutex_set_increment", (PyCFunction)DBEnv_mutex_set_increment,
+        METH_VARARGS},
+    {"mutex_get_increment", (PyCFunction)DBEnv_mutex_get_increment,
+        METH_NOARGS},
+    {"mutex_set_tas_spins", (PyCFunction)DBEnv_mutex_set_tas_spins,
+        METH_VARARGS},
+    {"mutex_get_tas_spins", (PyCFunction)DBEnv_mutex_get_tas_spins,
+        METH_NOARGS},
+    {"mutex_stat",      (PyCFunction)DBEnv_mutex_stat,      METH_VARARGS},
+#if (DBVER >= 44)
+    {"mutex_stat_print", (PyCFunction)DBEnv_mutex_stat_print,
+                                         METH_VARARGS|METH_KEYWORDS},
 #endif
-    {"set_timeout",     (PyCFunction)DBEnv_set_timeout,      METH_VARARGS|METH_KEYWORDS},
-    {"set_shm_key",     (PyCFunction)DBEnv_set_shm_key,      METH_VARARGS},
-    {"set_cachesize",   (PyCFunction)DBEnv_set_cachesize,    METH_VARARGS},
-    {"set_data_dir",    (PyCFunction)DBEnv_set_data_dir,     METH_VARARGS},
-    {"set_flags",       (PyCFunction)DBEnv_set_flags,        METH_VARARGS},
-#if (DBVER >= 47)
-    {"log_set_config",  (PyCFunction)DBEnv_log_set_config,   METH_VARARGS},
 #endif
-    {"set_lg_bsize",    (PyCFunction)DBEnv_set_lg_bsize,     METH_VARARGS},
-    {"set_lg_dir",      (PyCFunction)DBEnv_set_lg_dir,       METH_VARARGS},
-    {"set_lg_max",      (PyCFunction)DBEnv_set_lg_max,       METH_VARARGS},
-#if (DBVER >= 42)
-    {"get_lg_max",      (PyCFunction)DBEnv_get_lg_max,       METH_NOARGS},
+    {"set_data_dir",    (PyCFunction)DBEnv_set_data_dir,    METH_VARARGS},
+    {"get_data_dirs",   (PyCFunction)DBEnv_get_data_dirs,   METH_NOARGS},
+    {"get_flags",       (PyCFunction)DBEnv_get_flags,       METH_NOARGS},
+    {"set_flags",       (PyCFunction)DBEnv_set_flags,       METH_VARARGS},
+#if (DBVER >= 47)
+    {"log_set_config",  (PyCFunction)DBEnv_log_set_config,  METH_VARARGS},
+    {"log_get_config",  (PyCFunction)DBEnv_log_get_config,  METH_VARARGS},
 #endif
+    {"set_lg_bsize",    (PyCFunction)DBEnv_set_lg_bsize,    METH_VARARGS},
+    {"get_lg_bsize",    (PyCFunction)DBEnv_get_lg_bsize,    METH_NOARGS},
+    {"set_lg_dir",      (PyCFunction)DBEnv_set_lg_dir,      METH_VARARGS},
+    {"get_lg_dir",      (PyCFunction)DBEnv_get_lg_dir,      METH_NOARGS},
+    {"set_lg_max",      (PyCFunction)DBEnv_set_lg_max,      METH_VARARGS},
+    {"get_lg_max",      (PyCFunction)DBEnv_get_lg_max,      METH_NOARGS},
     {"set_lg_regionmax",(PyCFunction)DBEnv_set_lg_regionmax, METH_VARARGS},
-    {"set_lk_detect",   (PyCFunction)DBEnv_set_lk_detect,    METH_VARARGS},
+    {"get_lg_regionmax",(PyCFunction)DBEnv_get_lg_regionmax, METH_NOARGS},
+#if (DBVER >= 44)
+    {"set_lg_filemode", (PyCFunction)DBEnv_set_lg_filemode, METH_VARARGS},
+    {"get_lg_filemode", (PyCFunction)DBEnv_get_lg_filemode, METH_NOARGS},
+#endif
+#if (DBVER >= 47)
+    {"set_lk_partitions", (PyCFunction)DBEnv_set_lk_partitions, METH_VARARGS},
+    {"get_lk_partitions", (PyCFunction)DBEnv_get_lk_partitions, METH_NOARGS},
+#endif
+    {"set_lk_detect",   (PyCFunction)DBEnv_set_lk_detect,   METH_VARARGS},
+    {"get_lk_detect",   (PyCFunction)DBEnv_get_lk_detect,   METH_NOARGS},
 #if (DBVER < 45)
-    {"set_lk_max",      (PyCFunction)DBEnv_set_lk_max,       METH_VARARGS},
+    {"set_lk_max",      (PyCFunction)DBEnv_set_lk_max,      METH_VARARGS},
 #endif
     {"set_lk_max_locks", (PyCFunction)DBEnv_set_lk_max_locks, METH_VARARGS},
+    {"get_lk_max_locks", (PyCFunction)DBEnv_get_lk_max_locks, METH_NOARGS},
     {"set_lk_max_lockers", (PyCFunction)DBEnv_set_lk_max_lockers, METH_VARARGS},
+    {"get_lk_max_lockers", (PyCFunction)DBEnv_get_lk_max_lockers, METH_NOARGS},
     {"set_lk_max_objects", (PyCFunction)DBEnv_set_lk_max_objects, METH_VARARGS},
-    {"set_mp_mmapsize", (PyCFunction)DBEnv_set_mp_mmapsize,  METH_VARARGS},
-    {"set_tmp_dir",     (PyCFunction)DBEnv_set_tmp_dir,      METH_VARARGS},
-    {"txn_begin",       (PyCFunction)DBEnv_txn_begin,        METH_VARARGS|METH_KEYWORDS},
-    {"txn_checkpoint",  (PyCFunction)DBEnv_txn_checkpoint,   METH_VARARGS},
-    {"txn_stat",        (PyCFunction)DBEnv_txn_stat,         METH_VARARGS},
-    {"set_tx_max",      (PyCFunction)DBEnv_set_tx_max,       METH_VARARGS},
+    {"get_lk_max_objects", (PyCFunction)DBEnv_get_lk_max_objects, METH_NOARGS},
+    {"stat_print",          (PyCFunction)DBEnv_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+    {"set_mp_mmapsize", (PyCFunction)DBEnv_set_mp_mmapsize, METH_VARARGS},
+    {"get_mp_mmapsize", (PyCFunction)DBEnv_get_mp_mmapsize, METH_NOARGS},
+    {"set_tmp_dir",     (PyCFunction)DBEnv_set_tmp_dir,     METH_VARARGS},
+    {"get_tmp_dir",     (PyCFunction)DBEnv_get_tmp_dir,     METH_NOARGS},
+    {"txn_begin",       (PyCFunction)DBEnv_txn_begin,       METH_VARARGS|METH_KEYWORDS},
+    {"txn_checkpoint",  (PyCFunction)DBEnv_txn_checkpoint,  METH_VARARGS},
+    {"txn_stat",        (PyCFunction)DBEnv_txn_stat,        METH_VARARGS},
+    {"txn_stat_print",  (PyCFunction)DBEnv_txn_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+    {"get_tx_max",      (PyCFunction)DBEnv_get_tx_max,      METH_NOARGS},
+    {"get_tx_timestamp", (PyCFunction)DBEnv_get_tx_timestamp, METH_NOARGS},
+    {"set_tx_max",      (PyCFunction)DBEnv_set_tx_max,      METH_VARARGS},
     {"set_tx_timestamp", (PyCFunction)DBEnv_set_tx_timestamp, METH_VARARGS},
-    {"lock_detect",     (PyCFunction)DBEnv_lock_detect,      METH_VARARGS},
-    {"lock_get",        (PyCFunction)DBEnv_lock_get,         METH_VARARGS},
-    {"lock_id",         (PyCFunction)DBEnv_lock_id,          METH_NOARGS},
-    {"lock_id_free",    (PyCFunction)DBEnv_lock_id_free,     METH_VARARGS},
-    {"lock_put",        (PyCFunction)DBEnv_lock_put,         METH_VARARGS},
-    {"lock_stat",       (PyCFunction)DBEnv_lock_stat,        METH_VARARGS},
-    {"log_archive",     (PyCFunction)DBEnv_log_archive,      METH_VARARGS},
-    {"log_flush",       (PyCFunction)DBEnv_log_flush,        METH_NOARGS},
-    {"log_stat",        (PyCFunction)DBEnv_log_stat,         METH_VARARGS},
+    {"lock_detect",     (PyCFunction)DBEnv_lock_detect,     METH_VARARGS},
+    {"lock_get",        (PyCFunction)DBEnv_lock_get,        METH_VARARGS},
+    {"lock_id",         (PyCFunction)DBEnv_lock_id,         METH_NOARGS},
+    {"lock_id_free",    (PyCFunction)DBEnv_lock_id_free,    METH_VARARGS},
+    {"lock_put",        (PyCFunction)DBEnv_lock_put,        METH_VARARGS},
+    {"lock_stat",       (PyCFunction)DBEnv_lock_stat,       METH_VARARGS},
+    {"lock_stat_print", (PyCFunction)DBEnv_lock_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+    {"log_cursor",      (PyCFunction)DBEnv_log_cursor,      METH_NOARGS},
+    {"log_file",        (PyCFunction)DBEnv_log_file,        METH_VARARGS},
+#if (DBVER >= 44)
+    {"log_printf",      (PyCFunction)DBEnv_log_printf,
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"log_archive",     (PyCFunction)DBEnv_log_archive,     METH_VARARGS},
+    {"log_flush",       (PyCFunction)DBEnv_log_flush,       METH_NOARGS},
+    {"log_stat",        (PyCFunction)DBEnv_log_stat,        METH_VARARGS},
+    {"log_stat_print",  (PyCFunction)DBEnv_log_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
 #if (DBVER >= 44)
-    {"lsn_reset",       (PyCFunction)DBEnv_lsn_reset,        METH_VARARGS|METH_KEYWORDS},
+    {"fileid_reset",    (PyCFunction)DBEnv_fileid_reset,    METH_VARARGS|METH_KEYWORDS},
+    {"lsn_reset",       (PyCFunction)DBEnv_lsn_reset,       METH_VARARGS|METH_KEYWORDS},
 #endif
     {"set_get_returns_none",(PyCFunction)DBEnv_set_get_returns_none, METH_VARARGS},
-    {"txn_recover",     (PyCFunction)DBEnv_txn_recover,       METH_NOARGS},
+    {"txn_recover",     (PyCFunction)DBEnv_txn_recover,     METH_NOARGS},
 #if (DBVER < 48)
     {"set_rpc_server",  (PyCFunction)DBEnv_set_rpc_server,
-        METH_VARARGS||METH_KEYWORDS},
+        METH_VARARGS|METH_KEYWORDS},
+#endif
+    {"set_mp_max_openfd", (PyCFunction)DBEnv_set_mp_max_openfd, METH_VARARGS},
+    {"get_mp_max_openfd", (PyCFunction)DBEnv_get_mp_max_openfd, METH_NOARGS},
+    {"set_mp_max_write", (PyCFunction)DBEnv_set_mp_max_write, METH_VARARGS},
+    {"get_mp_max_write", (PyCFunction)DBEnv_get_mp_max_write, METH_NOARGS},
+    {"set_verbose",     (PyCFunction)DBEnv_set_verbose,     METH_VARARGS},
+    {"get_verbose",     (PyCFunction)DBEnv_get_verbose,     METH_VARARGS},
+    {"set_private",     (PyCFunction)DBEnv_set_private,     METH_O},
+    {"get_private",     (PyCFunction)DBEnv_get_private,     METH_NOARGS},
+    {"get_open_flags",  (PyCFunction)DBEnv_get_open_flags,  METH_NOARGS},
+#if (DBVER >= 47)
+    {"set_intermediate_dir_mode", (PyCFunction)DBEnv_set_intermediate_dir_mode,
+        METH_VARARGS},
+    {"get_intermediate_dir_mode", (PyCFunction)DBEnv_get_intermediate_dir_mode,
+        METH_NOARGS},
 #endif
-    {"set_verbose",     (PyCFunction)DBEnv_set_verbose,       METH_VARARGS},
-#if (DBVER >= 42)
-    {"get_verbose",     (PyCFunction)DBEnv_get_verbose,       METH_VARARGS},
+#if (DBVER < 47)
+    {"set_intermediate_dir", (PyCFunction)DBEnv_set_intermediate_dir,
+        METH_VARARGS},
 #endif
-    {"set_private",     (PyCFunction)DBEnv_set_private,       METH_O},
-    {"get_private",     (PyCFunction)DBEnv_get_private,       METH_NOARGS},
     {"rep_start",       (PyCFunction)DBEnv_rep_start,
         METH_VARARGS|METH_KEYWORDS},
     {"rep_set_transport", (PyCFunction)DBEnv_rep_set_transport, METH_VARARGS},
@@ -6593,13 +9053,24 @@
     {"rep_set_timeout", (PyCFunction)DBEnv_rep_set_timeout, METH_VARARGS},
     {"rep_get_timeout", (PyCFunction)DBEnv_rep_get_timeout, METH_VARARGS},
 #endif
+#if (DBVER >= 47)
+    {"rep_set_clockskew", (PyCFunction)DBEnv_rep_set_clockskew, METH_VARARGS},
+    {"rep_get_clockskew", (PyCFunction)DBEnv_rep_get_clockskew, METH_VARARGS},
+#endif
+    {"rep_stat", (PyCFunction)DBEnv_rep_stat,
+        METH_VARARGS|METH_KEYWORDS},
+    {"rep_stat_print", (PyCFunction)DBEnv_rep_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
+
 #if (DBVER >= 45)
     {"repmgr_start", (PyCFunction)DBEnv_repmgr_start,
         METH_VARARGS|METH_KEYWORDS},
+#if (DBVER < 52)
     {"repmgr_set_local_site", (PyCFunction)DBEnv_repmgr_set_local_site,
         METH_VARARGS|METH_KEYWORDS},
     {"repmgr_add_remote_site", (PyCFunction)DBEnv_repmgr_add_remote_site,
         METH_VARARGS|METH_KEYWORDS},
+#endif
     {"repmgr_set_ack_policy", (PyCFunction)DBEnv_repmgr_set_ack_policy,
         METH_VARARGS},
     {"repmgr_get_ack_policy", (PyCFunction)DBEnv_repmgr_get_ack_policy,
@@ -6613,6 +9084,12 @@
     {"repmgr_stat_print", (PyCFunction)DBEnv_repmgr_stat_print,
         METH_VARARGS|METH_KEYWORDS},
 #endif
+#if (DBVER >= 52)
+    {"repmgr_site", (PyCFunction)DBEnv_repmgr_site,
+        METH_VARARGS | METH_KEYWORDS},
+    {"repmgr_site_by_eid",  (PyCFunction)DBEnv_repmgr_site_by_eid,
+        METH_VARARGS | METH_KEYWORDS},
+#endif
     {NULL,      NULL}       /* sentinel */
 };
 
@@ -6623,17 +9100,22 @@
     {"discard",         (PyCFunction)DBTxn_discard,     METH_NOARGS},
     {"abort",           (PyCFunction)DBTxn_abort,       METH_NOARGS},
     {"id",              (PyCFunction)DBTxn_id,          METH_NOARGS},
+    {"set_timeout",     (PyCFunction)DBTxn_set_timeout,
+        METH_VARARGS|METH_KEYWORDS},
+#if (DBVER >= 44)
+    {"set_name",        (PyCFunction)DBTxn_set_name, METH_VARARGS},
+    {"get_name",        (PyCFunction)DBTxn_get_name, METH_NOARGS},
+#endif
     {NULL,      NULL}       /* sentinel */
 };
 
 
-#if (DBVER >= 43)
 static PyMethodDef DBSequence_methods[] = {
     {"close",           (PyCFunction)DBSequence_close,          METH_VARARGS},
     {"get",             (PyCFunction)DBSequence_get,            METH_VARARGS|METH_KEYWORDS},
     {"get_dbp",         (PyCFunction)DBSequence_get_dbp,        METH_NOARGS},
     {"get_key",         (PyCFunction)DBSequence_get_key,        METH_NOARGS},
-    {"init_value",      (PyCFunction)DBSequence_init_value,     METH_VARARGS},
+    {"initial_value",   (PyCFunction)DBSequence_initial_value,  METH_VARARGS},
     {"open",            (PyCFunction)DBSequence_open,           METH_VARARGS|METH_KEYWORDS},
     {"remove",          (PyCFunction)DBSequence_remove,         METH_VARARGS|METH_KEYWORDS},
     {"set_cachesize",   (PyCFunction)DBSequence_set_cachesize,  METH_VARARGS},
@@ -6643,9 +9125,10 @@
     {"set_range",       (PyCFunction)DBSequence_set_range,      METH_VARARGS},
     {"get_range",       (PyCFunction)DBSequence_get_range,      METH_NOARGS},
     {"stat",            (PyCFunction)DBSequence_stat,           METH_VARARGS|METH_KEYWORDS},
+    {"stat_print",      (PyCFunction)DBSequence_stat_print,
+        METH_VARARGS|METH_KEYWORDS},
     {NULL,      NULL}       /* sentinel */
 };
-#endif
 
 
 static PyObject*
@@ -6655,11 +9138,9 @@
 
     CHECK_ENV_NOT_CLOSED(self);
 
-#if (DBVER >= 42)
+    MYDB_BEGIN_ALLOW_THREADS;
     self->db_env->get_home(self->db_env, &home);
-#else
-    home=self->db_env->db_home;
-#endif
+    MYDB_END_ALLOW_THREADS;
 
     if (home == NULL) {
         RETURN_NONE();
@@ -6691,7 +9172,7 @@
     0,          /*tp_compare*/
     0,          /*tp_repr*/
     0,          /*tp_as_number*/
-    0,          /*tp_as_sequence*/
+    &DB_sequence,/*tp_as_sequence*/
     &DB_mapping,/*tp_as_mapping*/
     0,          /*tp_hash*/
     0,                  /* tp_call */
@@ -6759,6 +9240,92 @@
 };
 
 
+statichere PyTypeObject DBLogCursor_Type = {
+#if (PY_VERSION_HEX < 0x03000000)
+    PyObject_HEAD_INIT(NULL)
+    0,                  /*ob_size*/
+#else
+    PyVarObject_HEAD_INIT(NULL, 0)
+#endif
+    "DBLogCursor",         /*tp_name*/
+    sizeof(DBLogCursorObject),  /*tp_basicsize*/
+    0,          /*tp_itemsize*/
+    /* methods */
+    (destructor)DBLogCursor_dealloc,/*tp_dealloc*/
+    0,          /*tp_print*/
+    0,          /*tp_getattr*/
+    0,          /*tp_setattr*/
+    0,          /*tp_compare*/
+    0,          /*tp_repr*/
+    0,          /*tp_as_number*/
+    0,          /*tp_as_sequence*/
+    0,          /*tp_as_mapping*/
+    0,          /*tp_hash*/
+    0,          /*tp_call*/
+    0,          /*tp_str*/
+    0,          /*tp_getattro*/
+    0,          /*tp_setattro*/
+    0,          /*tp_as_buffer*/
+#if (PY_VERSION_HEX < 0x03000000)
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS,      /* tp_flags */
+#else
+    Py_TPFLAGS_DEFAULT,      /* tp_flags */
+#endif
+    0,          /* tp_doc */
+    0,          /* tp_traverse */
+    0,          /* tp_clear */
+    0,          /* tp_richcompare */
+    offsetof(DBLogCursorObject, in_weakreflist),   /* tp_weaklistoffset */
+    0,          /*tp_iter*/
+    0,          /*tp_iternext*/
+    DBLogCursor_methods, /*tp_methods*/
+    0,          /*tp_members*/
+};
+
+#if (DBVER >= 52)
+statichere PyTypeObject DBSite_Type = {
+#if (PY_VERSION_HEX < 0x03000000)
+    PyObject_HEAD_INIT(NULL)
+    0,                  /*ob_size*/
+#else
+    PyVarObject_HEAD_INIT(NULL, 0)
+#endif
+    "DBSite",         /*tp_name*/
+    sizeof(DBSiteObject),  /*tp_basicsize*/
+    0,          /*tp_itemsize*/
+    /* methods */
+    (destructor)DBSite_dealloc,/*tp_dealloc*/
+    0,          /*tp_print*/
+    0,          /*tp_getattr*/
+    0,          /*tp_setattr*/
+    0,          /*tp_compare*/
+    0,          /*tp_repr*/
+    0,          /*tp_as_number*/
+    0,          /*tp_as_sequence*/
+    0,          /*tp_as_mapping*/
+    0,          /*tp_hash*/
+    0,          /*tp_call*/
+    0,          /*tp_str*/
+    0,          /*tp_getattro*/
+    0,          /*tp_setattro*/
+    0,          /*tp_as_buffer*/
+#if (PY_VERSION_HEX < 0x03000000)
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS,      /* tp_flags */
+#else
+    Py_TPFLAGS_DEFAULT,      /* tp_flags */
+#endif
+    0,          /* tp_doc */
+    0,          /* tp_traverse */
+    0,          /* tp_clear */
+    0,          /* tp_richcompare */
+    offsetof(DBSiteObject, in_weakreflist),   /* tp_weaklistoffset */
+    0,          /*tp_iter*/
+    0,          /*tp_iternext*/
+    DBSite_methods, /*tp_methods*/
+    0,          /*tp_members*/
+};
+#endif
+
 statichere PyTypeObject DBEnv_Type = {
 #if (PY_VERSION_HEX < 0x03000000)
     PyObject_HEAD_INIT(NULL)
@@ -6883,7 +9450,6 @@
     offsetof(DBLockObject, in_weakreflist),   /* tp_weaklistoffset */
 };
 
-#if (DBVER >= 43)
 statichere PyTypeObject DBSequence_Type = {
 #if (PY_VERSION_HEX < 0x03000000)
     PyObject_HEAD_INIT(NULL)
@@ -6925,7 +9491,6 @@
     DBSequence_methods, /*tp_methods*/
     0,          /*tp_members*/
 };
-#endif
 
 /* --------------------------------------------------------------------- */
 /* Module-level functions */
@@ -6959,7 +9524,6 @@
     return (PyObject* )newDBEnvObject(flags);
 }
 
-#if (DBVER >= 43)
 static PyObject*
 DBSequence_construct(PyObject* self, PyObject* args, PyObject* kwargs)
 {
@@ -6975,7 +9539,6 @@
     }
     return (PyObject* )newDBSequenceObject((DBObject*)dbobj, flags);
 }
-#endif
 
 static char bsddb_version_doc[] =
 "Returns a tuple of major, minor, and patch release numbers of the\n\
@@ -6986,19 +9549,35 @@
 {
     int major, minor, patch;
 
+    /* This should be instantaneous, no need to release the GIL */
     db_version(&major, &minor, &patch);
     return Py_BuildValue("(iii)", major, minor, patch);
 }
 
+#if (DBVER >= 50)
+static PyObject*
+bsddb_version_full(PyObject* self)
+{
+    char *version_string;
+    int family, release, major, minor, patch;
+
+    /* This should be instantaneous, no need to release the GIL */
+    version_string = db_full_version(&family, &release, &major, &minor, &patch);
+    return Py_BuildValue("(siiiii)",
+            version_string, family, release, major, minor, patch);
+}
+#endif
+
 
 /* List of functions defined in the module */
 static PyMethodDef bsddb_methods[] = {
     {"DB",          (PyCFunction)DB_construct,          METH_VARARGS | METH_KEYWORDS },
     {"DBEnv",       (PyCFunction)DBEnv_construct,       METH_VARARGS},
-#if (DBVER >= 43)
     {"DBSequence",  (PyCFunction)DBSequence_construct,  METH_VARARGS | METH_KEYWORDS },
-#endif
     {"version",     (PyCFunction)bsddb_version,         METH_NOARGS, bsddb_version_doc},
+#if (DBVER >= 50)
+    {"full_version", (PyCFunction)bsddb_version_full, METH_NOARGS},
+#endif
     {NULL,      NULL}       /* sentinel */
 };
 
@@ -7016,6 +9595,11 @@
  */
 #define ADD_INT(dict, NAME)         _addIntToDict(dict, #NAME, NAME)
 
+/*
+** We can rename the module at import time, so the string allocated
+** must be big enough, and any use of the name must use this particular
+** string.
+*/
 #define MODULE_NAME_MAX_LEN     11
 static char _bsddbModuleName[MODULE_NAME_MAX_LEN+1] = "_bsddb";
 
@@ -7043,19 +9627,32 @@
 {
     PyObject* m;
     PyObject* d;
-    PyObject* pybsddb_version_s = PyBytes_FromString( PY_BSDDB_VERSION );
-    PyObject* db_version_s = PyBytes_FromString( DB_VERSION_STRING );
-    PyObject* cvsid_s = PyBytes_FromString( rcs_id );
     PyObject* py_api;
+    PyObject* pybsddb_version_s;
+    PyObject* db_version_s;
+    PyObject* cvsid_s;
+
+#if (PY_VERSION_HEX < 0x03000000)
+    pybsddb_version_s = PyString_FromString(PY_BSDDB_VERSION);
+    db_version_s = PyString_FromString(DB_VERSION_STRING);
+    cvsid_s = PyString_FromString(rcs_id);
+#else
+    /* This data should be ascii, so UTF-8 conversion is fine */
+    pybsddb_version_s = PyUnicode_FromString(PY_BSDDB_VERSION);
+    db_version_s = PyUnicode_FromString(DB_VERSION_STRING);
+    cvsid_s = PyUnicode_FromString(rcs_id);
+#endif
 
     /* Initialize object types */
     if ((PyType_Ready(&DB_Type) < 0)
         || (PyType_Ready(&DBCursor_Type) < 0)
+        || (PyType_Ready(&DBLogCursor_Type) < 0)
         || (PyType_Ready(&DBEnv_Type) < 0)
         || (PyType_Ready(&DBTxn_Type) < 0)
         || (PyType_Ready(&DBLock_Type) < 0)
-#if (DBVER >= 43)
         || (PyType_Ready(&DBSequence_Type) < 0)
+#if (DBVER >= 52)
+        || (PyType_Ready(&DBSite_Type) < 0)
 #endif
         ) {
 #if (PY_VERSION_HEX < 0x03000000)
@@ -7065,11 +9662,6 @@
 #endif
     }
 
-#if defined(WITH_THREAD) && !defined(MYDB_USE_GILSTATE)
-    /* Save the current interpreter, so callbacks can do the right thing. */
-    _db_interpreterState = PyThreadState_GET()->interp;
-#endif
-
     /* Create the module and add the functions */
 #if (PY_VERSION_HEX < 0x03000000)
     m = Py_InitModule(_bsddbModuleName, bsddb_methods);
@@ -7104,13 +9696,7 @@
     ADD_INT(d, DB_MAX_RECORDS);
 
 #if (DBVER < 48)
-#if (DBVER >= 42)
     ADD_INT(d, DB_RPCCLIENT);
-#else
-    ADD_INT(d, DB_CLIENT);
-    /* allow apps to be written using DB_RPCCLIENT on older Berkeley DB */
-    _addIntToDict(d, "DB_RPCCLIENT", DB_CLIENT);
-#endif
 #endif
 
 #if (DBVER < 48)
@@ -7153,6 +9739,18 @@
     ADD_INT(d, DB_TXN_SYNC);
     ADD_INT(d, DB_TXN_NOWAIT);
 
+#if (DBVER >= 51)
+    ADD_INT(d, DB_TXN_BULK);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_CURSOR_BULK);
+#endif
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_TXN_WAIT);
+#endif
+
     ADD_INT(d, DB_EXCL);
     ADD_INT(d, DB_FCNTL_LOCKING);
     ADD_INT(d, DB_ODDFILESIZE);
@@ -7164,6 +9762,7 @@
     ADD_INT(d, DB_VERIFY);
     ADD_INT(d, DB_UPGRADE);
 
+    ADD_INT(d, DB_PRINTABLE);
     ADD_INT(d, DB_AGGRESSIVE);
     ADD_INT(d, DB_NOORDERCHK);
     ADD_INT(d, DB_ORDERCHKONLY);
@@ -7182,9 +9781,7 @@
     ADD_INT(d, DB_LOCK_MINWRITE);
 
     ADD_INT(d, DB_LOCK_EXPIRE);
-#if (DBVER >= 43)
     ADD_INT(d, DB_LOCK_MAXWRITE);
-#endif
 
     _addIntToDict(d, "DB_LOCK_CONFLICT", 0);
 
@@ -7220,9 +9817,6 @@
     ADD_INT(d, DB_LOCK_UPGRADE);
 
     ADD_INT(d, DB_LSTAT_ABORTED);
-#if (DBVER < 43)
-    ADD_INT(d, DB_LSTAT_ERR);
-#endif
     ADD_INT(d, DB_LSTAT_FREE);
     ADD_INT(d, DB_LSTAT_HELD);
 
@@ -7232,9 +9826,7 @@
     ADD_INT(d, DB_ARCH_ABS);
     ADD_INT(d, DB_ARCH_DATA);
     ADD_INT(d, DB_ARCH_LOG);
-#if (DBVER >= 42)
     ADD_INT(d, DB_ARCH_REMOVE);
-#endif
 
     ADD_INT(d, DB_BTREE);
     ADD_INT(d, DB_HASH);
@@ -7249,6 +9841,8 @@
     ADD_INT(d, DB_REVSPLITOFF);
     ADD_INT(d, DB_SNAPSHOT);
 
+    ADD_INT(d, DB_INORDER);
+
     ADD_INT(d, DB_JOIN_NOSORT);
 
     ADD_INT(d, DB_AFTER);
@@ -7258,15 +9852,6 @@
     ADD_INT(d, DB_CACHED_COUNTS);
 #endif
 
-#if (DBVER >= 41)
-    _addIntToDict(d, "DB_CHECKPOINT", 0);
-#else
-    ADD_INT(d, DB_CHECKPOINT);
-    ADD_INT(d, DB_CURLSN);
-#endif
-#if (DBVER <= 41)
-    ADD_INT(d, DB_COMMIT);
-#endif
     ADD_INT(d, DB_CONSUME);
     ADD_INT(d, DB_CONSUME_WAIT);
     ADD_INT(d, DB_CURRENT);
@@ -7274,6 +9859,7 @@
     ADD_INT(d, DB_FIRST);
     ADD_INT(d, DB_FLUSH);
     ADD_INT(d, DB_GET_BOTH);
+    ADD_INT(d, DB_GET_BOTH_RANGE);
     ADD_INT(d, DB_GET_RECNO);
     ADD_INT(d, DB_JOIN_ITEM);
     ADD_INT(d, DB_KEYFIRST);
@@ -7288,6 +9874,9 @@
     ADD_INT(d, DB_POSITION);
     ADD_INT(d, DB_PREV);
     ADD_INT(d, DB_PREV_NODUP);
+#if (DBVER >= 46)
+    ADD_INT(d, DB_PREV_DUP);
+#endif
 #if (DBVER < 45)
     ADD_INT(d, DB_RECORDCOUNT);
 #endif
@@ -7303,24 +9892,27 @@
     ADD_INT(d, DB_MULTIPLE_KEY);
 
 #if (DBVER >= 44)
+    ADD_INT(d, DB_IMMUTABLE_KEY);
     ADD_INT(d, DB_READ_UNCOMMITTED);    /* replaces DB_DIRTY_READ in 4.4 */
     ADD_INT(d, DB_READ_COMMITTED);
 #endif
 
+#if (DBVER >= 44)
+    ADD_INT(d, DB_FREELIST_ONLY);
+    ADD_INT(d, DB_FREE_SPACE);
+#endif
+
     ADD_INT(d, DB_DONOTINDEX);
 
-#if (DBVER >= 41)
-    _addIntToDict(d, "DB_INCOMPLETE", 0);
-#else
-    ADD_INT(d, DB_INCOMPLETE);
-#endif
     ADD_INT(d, DB_KEYEMPTY);
     ADD_INT(d, DB_KEYEXIST);
     ADD_INT(d, DB_LOCK_DEADLOCK);
     ADD_INT(d, DB_LOCK_NOTGRANTED);
     ADD_INT(d, DB_NOSERVER);
+#if (DBVER < 52)
     ADD_INT(d, DB_NOSERVER_HOME);
     ADD_INT(d, DB_NOSERVER_ID);
+#endif
     ADD_INT(d, DB_NOTFOUND);
     ADD_INT(d, DB_OLD_VERSION);
     ADD_INT(d, DB_RUNRECOVERY);
@@ -7333,16 +9925,32 @@
     ADD_INT(d, DB_YIELDCPU);
     ADD_INT(d, DB_PANIC_ENVIRONMENT);
     ADD_INT(d, DB_NOPANIC);
-
-#if (DBVER >= 41)
     ADD_INT(d, DB_OVERWRITE);
+
+    ADD_INT(d, DB_STAT_SUBSYSTEM);
+    ADD_INT(d, DB_STAT_MEMP_HASH);
+    ADD_INT(d, DB_STAT_LOCK_CONF);
+    ADD_INT(d, DB_STAT_LOCK_LOCKERS);
+    ADD_INT(d, DB_STAT_LOCK_OBJECTS);
+    ADD_INT(d, DB_STAT_LOCK_PARAMS);
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_OVERWRITE_DUP);
 #endif
 
-#ifdef DB_REGISTER
+#if (DBVER >= 47)
+    ADD_INT(d, DB_FOREIGN_ABORT);
+    ADD_INT(d, DB_FOREIGN_CASCADE);
+    ADD_INT(d, DB_FOREIGN_NULLIFY);
+#endif
+
+#if (DBVER >= 44)
     ADD_INT(d, DB_REGISTER);
 #endif
 
-#if (DBVER >= 42)
+    ADD_INT(d, DB_EID_INVALID);
+    ADD_INT(d, DB_EID_BROADCAST);
+
     ADD_INT(d, DB_TIME_NOTGRANTED);
     ADD_INT(d, DB_TXN_NOT_DURABLE);
     ADD_INT(d, DB_TXN_WRITE_NOSYNC);
@@ -7350,9 +9958,8 @@
     ADD_INT(d, DB_INIT_REP);
     ADD_INT(d, DB_ENCRYPT);
     ADD_INT(d, DB_CHKSUM);
-#endif
 
-#if (DBVER >= 42) && (DBVER < 47)
+#if (DBVER < 47)
     ADD_INT(d, DB_LOG_AUTOREMOVE);
     ADD_INT(d, DB_DIRECT_LOG);
 #endif
@@ -7385,6 +9992,20 @@
     ADD_INT(d, DB_VERB_REPLICATION);
     ADD_INT(d, DB_VERB_WAITSFOR);
 
+#if (DBVER >= 50)
+    ADD_INT(d, DB_VERB_REP_SYSTEM);
+#endif
+
+#if (DBVER >= 47)
+    ADD_INT(d, DB_VERB_REP_ELECT);
+    ADD_INT(d, DB_VERB_REP_LEASE);
+    ADD_INT(d, DB_VERB_REP_MISC);
+    ADD_INT(d, DB_VERB_REP_MSGS);
+    ADD_INT(d, DB_VERB_REP_SYNC);
+    ADD_INT(d, DB_VERB_REPMGR_CONNFAIL);
+    ADD_INT(d, DB_VERB_REPMGR_MISC);
+#endif
+
 #if (DBVER >= 45)
     ADD_INT(d, DB_EVENT_PANIC);
     ADD_INT(d, DB_EVENT_REP_CLIENT);
@@ -7400,20 +10021,82 @@
     ADD_INT(d, DB_EVENT_WRITE_FAILED);
 #endif
 
+#if (DBVER >= 50)
+    ADD_INT(d, DB_REPMGR_CONF_ELECTIONS);
+    ADD_INT(d, DB_EVENT_REP_MASTER_FAILURE);
+    ADD_INT(d, DB_EVENT_REP_DUPMASTER);
+    ADD_INT(d, DB_EVENT_REP_ELECTION_FAILED);
+#endif
+#if (DBVER >= 48)
+    ADD_INT(d, DB_EVENT_REG_ALIVE);
+    ADD_INT(d, DB_EVENT_REG_PANIC);
+#endif
+
+#if (DBVER >=52)
+    ADD_INT(d, DB_EVENT_REP_SITE_ADDED);
+    ADD_INT(d, DB_EVENT_REP_SITE_REMOVED);
+    ADD_INT(d, DB_EVENT_REP_LOCAL_SITE_REMOVED);
+    ADD_INT(d, DB_EVENT_REP_CONNECT_BROKEN);
+    ADD_INT(d, DB_EVENT_REP_CONNECT_ESTD);
+    ADD_INT(d, DB_EVENT_REP_CONNECT_TRY_FAILED);
+    ADD_INT(d, DB_EVENT_REP_INIT_DONE);
+
+    ADD_INT(d, DB_MEM_LOCK);
+    ADD_INT(d, DB_MEM_LOCKOBJECT);
+    ADD_INT(d, DB_MEM_LOCKER);
+    ADD_INT(d, DB_MEM_LOGID);
+    ADD_INT(d, DB_MEM_TRANSACTION);
+    ADD_INT(d, DB_MEM_THREAD);
+
+    ADD_INT(d, DB_BOOTSTRAP_HELPER);
+    ADD_INT(d, DB_GROUP_CREATOR);
+    ADD_INT(d, DB_LEGACY);
+    ADD_INT(d, DB_LOCAL_SITE);
+    ADD_INT(d, DB_REPMGR_PEER);
+#endif
+
     ADD_INT(d, DB_REP_DUPMASTER);
     ADD_INT(d, DB_REP_HOLDELECTION);
 #if (DBVER >= 44)
     ADD_INT(d, DB_REP_IGNORE);
     ADD_INT(d, DB_REP_JOIN_FAILURE);
 #endif
-#if (DBVER >= 42)
     ADD_INT(d, DB_REP_ISPERM);
     ADD_INT(d, DB_REP_NOTPERM);
-#endif
     ADD_INT(d, DB_REP_NEWSITE);
 
     ADD_INT(d, DB_REP_MASTER);
     ADD_INT(d, DB_REP_CLIENT);
+
+    ADD_INT(d, DB_REP_PERMANENT);
+
+#if (DBVER >= 44)
+#if (DBVER >= 50)
+    ADD_INT(d, DB_REP_CONF_AUTOINIT);
+#else
+    ADD_INT(d, DB_REP_CONF_NOAUTOINIT);
+#endif /* 5.0 */
+#endif /* 4.4 */
+#if (DBVER >= 44)
+    ADD_INT(d, DB_REP_CONF_DELAYCLIENT);
+    ADD_INT(d, DB_REP_CONF_BULK);
+    ADD_INT(d, DB_REP_CONF_NOWAIT);
+    ADD_INT(d, DB_REP_ANYWHERE);
+    ADD_INT(d, DB_REP_REREQUEST);
+#endif
+
+    ADD_INT(d, DB_REP_NOBUFFER);
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_REP_LEASE_EXPIRED);
+    ADD_INT(d, DB_IGNORE_LEASE);
+#endif
+
+#if (DBVER >= 47)
+    ADD_INT(d, DB_REP_CONF_LEASE);
+    ADD_INT(d, DB_REPMGR_CONF_2SITE_STRICT);
+#endif
+
 #if (DBVER >= 45)
     ADD_INT(d, DB_REP_ELECTION);
 
@@ -7425,6 +10108,11 @@
 #if (DBVER >= 46)
     ADD_INT(d, DB_REP_CHECKPOINT_DELAY);
     ADD_INT(d, DB_REP_FULL_ELECTION_TIMEOUT);
+    ADD_INT(d, DB_REP_LEASE_TIMEOUT);
+#endif
+#if (DBVER >= 47)
+    ADD_INT(d, DB_REP_HEARTBEAT_MONITOR);
+    ADD_INT(d, DB_REP_HEARTBEAT_SEND);
 #endif
 
 #if (DBVER >= 45)
@@ -7437,28 +10125,51 @@
     ADD_INT(d, DB_REPMGR_ACKS_QUORUM);
     ADD_INT(d, DB_REPMGR_CONNECTED);
     ADD_INT(d, DB_REPMGR_DISCONNECTED);
-    ADD_INT(d, DB_STAT_CLEAR);
     ADD_INT(d, DB_STAT_ALL);
 #endif
 
-#if (DBVER >= 43)
+#if (DBVER >= 51)
+    ADD_INT(d, DB_REPMGR_ACKS_ALL_AVAILABLE);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_REP_CONF_INMEM);
+#endif
+
+    ADD_INT(d, DB_TIMEOUT);
+
+#if (DBVER >= 50)
+    ADD_INT(d, DB_FORCESYNC);
+#endif
+
+#if (DBVER >= 48)
+    ADD_INT(d, DB_FAILCHK);
+#endif
+
+#if (DBVER >= 51)
+    ADD_INT(d, DB_HOTBACKUP_IN_PROGRESS);
+#endif
+
     ADD_INT(d, DB_BUFFER_SMALL);
     ADD_INT(d, DB_SEQ_DEC);
     ADD_INT(d, DB_SEQ_INC);
     ADD_INT(d, DB_SEQ_WRAP);
-#endif
 
-#if (DBVER >= 43) && (DBVER < 47)
+#if (DBVER < 47)
     ADD_INT(d, DB_LOG_INMEMORY);
     ADD_INT(d, DB_DSYNC_LOG);
 #endif
 
-#if (DBVER >= 41)
     ADD_INT(d, DB_ENCRYPT_AES);
     ADD_INT(d, DB_AUTO_COMMIT);
-#else
-    /* allow Berkeley DB 4.1 aware apps to run on older versions */
-    _addIntToDict(d, "DB_AUTO_COMMIT", 0);
+    ADD_INT(d, DB_PRIORITY_VERY_LOW);
+    ADD_INT(d, DB_PRIORITY_LOW);
+    ADD_INT(d, DB_PRIORITY_DEFAULT);
+    ADD_INT(d, DB_PRIORITY_HIGH);
+    ADD_INT(d, DB_PRIORITY_VERY_HIGH);
+
+#if (DBVER >= 46)
+    ADD_INT(d, DB_PRIORITY_UNCHANGED);
 #endif
 
     ADD_INT(d, EINVAL);
@@ -7474,6 +10185,10 @@
     ADD_INT(d, DB_SET_LOCK_TIMEOUT);
     ADD_INT(d, DB_SET_TXN_TIMEOUT);
 
+#if (DBVER >= 48)
+    ADD_INT(d, DB_SET_REG_TIMEOUT);
+#endif
+
     /* The exception name must be correct for pickled exception *
      * objects to unpickle properly.                            */
 #ifdef PYBSDDB_STANDALONE  /* different value needed for standalone pybsddb */
@@ -7522,12 +10237,7 @@
     }
 #endif
 
-
-#if !INCOMPLETE_IS_WARNING
-    MAKE_EX(DBIncompleteError);
-#endif
     MAKE_EX(DBCursorClosedError);
-    MAKE_EX(DBKeyEmptyError);
     MAKE_EX(DBKeyExistError);
     MAKE_EX(DBLockDeadlockError);
     MAKE_EX(DBLockNotGrantedError);
@@ -7535,8 +10245,10 @@
     MAKE_EX(DBRunRecoveryError);
     MAKE_EX(DBVerifyBadError);
     MAKE_EX(DBNoServerError);
+#if (DBVER < 52)
     MAKE_EX(DBNoServerHomeError);
     MAKE_EX(DBNoServerIDError);
+#endif
     MAKE_EX(DBPageNotFoundError);
     MAKE_EX(DBSecondaryBadError);
 
@@ -7550,28 +10262,73 @@
     MAKE_EX(DBNoSuchFileError);
     MAKE_EX(DBPermissionsError);
 
-#if (DBVER >= 42)
     MAKE_EX(DBRepHandleDeadError);
+#if (DBVER >= 44)
+    MAKE_EX(DBRepLockoutError);
 #endif
 
     MAKE_EX(DBRepUnavailError);
 
-#undef MAKE_EX
+#if (DBVER >= 46)
+    MAKE_EX(DBRepLeaseExpiredError);
+#endif
 
-    /* Initiliase the C API structure and add it to the module */
-    bsddb_api.db_type         = &DB_Type;
-    bsddb_api.dbcursor_type   = &DBCursor_Type;
-    bsddb_api.dbenv_type      = &DBEnv_Type;
-    bsddb_api.dbtxn_type      = &DBTxn_Type;
-    bsddb_api.dblock_type     = &DBLock_Type;
-#if (DBVER >= 43)
-    bsddb_api.dbsequence_type = &DBSequence_Type;
+#if (DBVER >= 47)
+        MAKE_EX(DBForeignConflictError);
 #endif
-    bsddb_api.makeDBError     = makeDBError;
 
+#undef MAKE_EX
+
+    /* Initialise the C API structure and add it to the module */
+    bsddb_api.api_version      = PYBSDDB_API_VERSION;
+    bsddb_api.db_type          = &DB_Type;
+    bsddb_api.dbcursor_type    = &DBCursor_Type;
+    bsddb_api.dblogcursor_type = &DBLogCursor_Type;
+    bsddb_api.dbenv_type       = &DBEnv_Type;
+    bsddb_api.dbtxn_type       = &DBTxn_Type;
+    bsddb_api.dblock_type      = &DBLock_Type;
+    bsddb_api.dbsequence_type  = &DBSequence_Type;
+    bsddb_api.makeDBError      = makeDBError;
+
+    /*
+    ** Capsules exist from Python 2.7 and 3.1.
+    ** We don't support Python 3.0 anymore, so...
+    ** #if (PY_VERSION_HEX < ((PY_MAJOR_VERSION < 3) ? 0x02070000 : 0x03020000))
+    */
+#if (PY_VERSION_HEX < 0x02070000)
     py_api = PyCObject_FromVoidPtr((void*)&bsddb_api, NULL);
-    PyDict_SetItemString(d, "api", py_api);
-    Py_DECREF(py_api);
+#else
+    {
+        /*
+        ** The data must outlive the call!!. So, the static definition.
+        ** The buffer must be big enough...
+        */
+        static char py_api_name[MODULE_NAME_MAX_LEN+10];
+
+        strcpy(py_api_name, _bsddbModuleName);
+        strcat(py_api_name, ".api");
+
+        py_api = PyCapsule_New((void*)&bsddb_api, py_api_name, NULL);
+    }
+#endif
+
+    /* Check error control */
+    /*
+    ** PyErr_NoMemory();
+    ** py_api = NULL;
+    */
+
+    if (py_api) {
+        PyDict_SetItemString(d, "api", py_api);
+        Py_DECREF(py_api);
+    } else { /* Something bad happened */
+        PyErr_WriteUnraisable(m);
+        if(PyErr_Warn(PyExc_RuntimeWarning,
+                "_bsddb/_pybsddb C API will be not available")) {
+            PyErr_WriteUnraisable(m);
+        }
+        PyErr_Clear();
+    }
 
     /* Check for errors */
     if (PyErr_Occurred()) {
--- a/Modules/bsddb.h
+++ b/Modules/bsddb.h
@@ -61,7 +61,7 @@
  *
  * http://www.python.org/peps/pep-0291.html
  *
- * This module contains 6 types:
+ * This module contains 7 types:
  *
  * DB           (Database)
  * DBCursor     (Database Cursor)
@@ -69,6 +69,11 @@
  * DBTxn        (An explicit database transaction)
  * DBLock       (A lock handle)
  * DBSequence   (Sequence)
+ * DBSite       (Site)
+ *
+ * New datatypes:
+ *
+ * DBLogCursor  (Log Cursor)
  *
  */
 
@@ -105,7 +110,7 @@
 #error "eek! DBVER can't handle minor versions > 9"
 #endif
 
-#define PY_BSDDB_VERSION "4.7.3"
+#define PY_BSDDB_VERSION "5.3.0"
 
 /* Python object definitions */
 
@@ -122,8 +127,12 @@
 
 struct DBObject;          /* Forward declaration */
 struct DBCursorObject;    /* Forward declaration */
+struct DBLogCursorObject; /* Forward declaration */
 struct DBTxnObject;       /* Forward declaration */
 struct DBSequenceObject;  /* Forward declaration */
+#if (DBVER >= 52)
+struct DBSiteObject;      /* Forward declaration */
+#endif
 
 typedef struct {
     PyObject_HEAD
@@ -134,6 +143,10 @@
     PyObject*       event_notifyCallback;
     struct DBObject *children_dbs;
     struct DBTxnObject *children_txns;
+    struct DBLogCursorObject *children_logcursors;
+#if (DBVER >= 52)
+    struct DBSiteObject *children_sites;
+#endif
     PyObject        *private_obj;
     PyObject        *rep_transport;
     PyObject        *in_weakreflist; /* List of weak references */
@@ -145,19 +158,17 @@
     DBEnvObject*    myenvobj;  /* PyObject containing the DB_ENV */
     u_int32_t       flags;     /* saved flags from open() */
     u_int32_t       setflags;  /* saved flags from set_flags() */
-    int             haveStat;
     struct behaviourFlags moduleFlags;
     struct DBTxnObject *txn;
     struct DBCursorObject *children_cursors;
-#if (DBVER >=43)
     struct DBSequenceObject *children_sequences;
-#endif
     struct DBObject **sibling_prev_p;
     struct DBObject *sibling_next;
     struct DBObject **sibling_prev_p_txn;
     struct DBObject *sibling_next_txn;
     PyObject*       associateCallback;
     PyObject*       btCompareCallback;
+    PyObject*       dupCompareCallback;	    
     int             primaryDBType;
     PyObject        *private_obj;
     PyObject        *in_weakreflist; /* List of weak references */
@@ -193,14 +204,34 @@
 } DBTxnObject;
 
 
+typedef struct DBLogCursorObject {
+    PyObject_HEAD
+    DB_LOGC*        logc;
+    DBEnvObject*    env;
+    struct DBLogCursorObject **sibling_prev_p;
+    struct DBLogCursorObject *sibling_next;
+    PyObject        *in_weakreflist; /* List of weak references */
+} DBLogCursorObject;
+
+#if (DBVER >= 52)
+typedef struct DBSiteObject {
+    PyObject_HEAD
+    DB_SITE         *site;
+    DBEnvObject     *env;
+    struct DBSiteObject **sibling_prev_p;
+    struct DBSiteObject *sibling_next;
+    PyObject    *in_weakreflist; /* List of weak references */
+} DBSiteObject;
+#endif
+
 typedef struct {
     PyObject_HEAD
     DB_LOCK         lock;
+    int             lock_initialized;  /* Signal if we actually have a lock */
     PyObject        *in_weakreflist; /* List of weak references */
 } DBLockObject;
 
 
-#if (DBVER >= 43)
 typedef struct DBSequenceObject {
     PyObject_HEAD
     DB_SEQUENCE*     sequence;
@@ -212,7 +243,6 @@
     struct DBSequenceObject *sibling_next_txn;
     PyObject        *in_weakreflist; /* List of weak references */
 } DBSequenceObject;
-#endif
 
 
 /* API structure for use by C code */
@@ -220,6 +250,7 @@
 /* To access the structure from an external module, use code like the
    following (error checking missed out for clarity):
 
+     // If you are using Python before 2.7:
      BSDDB_api* bsddb_api;
      PyObject*  mod;
      PyObject*  cobj;
@@ -231,23 +262,34 @@
      Py_DECREF(cobj);
      Py_DECREF(mod);
 
+
+     // If you are using Python 2.7 or up: (except Python 3.0, unsupported)
+     BSDDB_api* bsddb_api;
+
+     // Use "bsddb3._pybsddb.api" if you're using
+     // the standalone pybsddb add-on.
+     bsddb_api = (void **)PyCapsule_Import("bsddb._bsddb.api", 1);
+
+
+   Check "api_version" number before trying to use the API.
+
    The structure's members must not be changed.
 */
 
+#define PYBSDDB_API_VERSION 1
 typedef struct {
+    unsigned int api_version;
     /* Type objects */
     PyTypeObject* db_type;
     PyTypeObject* dbcursor_type;
+    PyTypeObject* dblogcursor_type;
     PyTypeObject* dbenv_type;
     PyTypeObject* dbtxn_type;
     PyTypeObject* dblock_type;
-#if (DBVER >= 43)
     PyTypeObject* dbsequence_type;
-#endif
 
     /* Functions */
     int (*makeDBError)(int err);
-
 } BSDDB_api;
 
 
@@ -263,9 +305,9 @@
 #define DBEnvObject_Check(v)    ((v)->ob_type == bsddb_api->dbenv_type)
 #define DBTxnObject_Check(v)    ((v)->ob_type == bsddb_api->dbtxn_type)
 #define DBLockObject_Check(v)   ((v)->ob_type == bsddb_api->dblock_type)
-#if (DBVER >= 43)
-#define DBSequenceObject_Check(v)  ((v)->ob_type == bsddb_api->dbsequence_type)
-#endif
+#define DBSequenceObject_Check(v)  \
+    ((bsddb_api->dbsequence_type) && \
+        ((v)->ob_type == bsddb_api->dbsequence_type))
 
 #endif /* COMPILING_BSDDB_C */
 
